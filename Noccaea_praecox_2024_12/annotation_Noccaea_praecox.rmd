---
title: "Annotation - Noccaea"
author: "Milos Duchoslav"
date: "2024_12_26"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Making new folders

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/
# make new folder and subfolders
mkdir Noccaea_praecox_2024_12
cd Noccaea_praecox_2024_12
mkdir genome_assembly
mkdir rnaseq
mkdir metacentrum_scripts
```

# Copying SW previously used only for Alyssum to shared folder
```{sh}
# copy SW from used for Alyssum annotation to SW folder
cp -Rv /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/braker_sw /storage/brno12-cerit/home/duchmil/SW/
cp -Rv /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/stringtie/ /storage/brno12-cerit/home/duchmil/SW/
cp -Rv /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/miniprot/ /storage/brno12-cerit/home/duchmil/SW/



```


# Preparation for annotation using Braker

## Genome assembly
```{sh}
# Copying assembly from Mahnaz
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/genome_assembly
# Assembly copied from google drive through my PC.

```

**Note:**
The pipeline was run with te name of assembly "Noccaea_polished_2024_10_Mahnaz.masked.fa". We then renamed it to "Noccaea_praecox_CUNI_V1_2024_10_masked.fa". It is the same assembly (the files have the same checksum).

### Checking assembly statistics
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/genome_assembly

# Current assembly
grep -c '>' Noccaea_polished_2024_10_Mahnaz.masked.fa # 49


module load quast
quast.py Noccaea_polished_2024_10_Mahnaz.masked.fa
less quast_results/results_2024_12_28_11_35_57/report.txt

module load seqtk
# info about columns
seqtk comp
# info about sequences
seqtk comp Noccaea_polished_2024_10_Mahnaz.masked.fa | column -t


```


```
Assembly                    Noccaea_polished_2024_10_Mahnaz.masked
# contigs (>= 0 bp)         49
# contigs (>= 1000 bp)      49
# contigs (>= 5000 bp)      49
# contigs (>= 10000 bp)     49
# contigs (>= 25000 bp)     49
# contigs (>= 50000 bp)     44
Total length (>= 0 bp)      253532312
Total length (>= 1000 bp)   253532312
Total length (>= 5000 bp)   253532312
Total length (>= 10000 bp)  253532312
Total length (>= 25000 bp)  253532312
Total length (>= 50000 bp)  253342675
# contigs                   49
Largest contig              38206310
Total length                253532312
GC (%)                      39.38
N50                         33891589
N75                         27307903
L50                         4
L75                         6
# N's per 100 kbp           0.12
```



## Preparation of RNAseq data
### Copying our RNAseq data
```{sh}
# Copy RNAseq data
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq
mkdir 1_raw_reads
cd 1_raw_reads
cp -vR /storage/brno12-cerit/home/filip_kolar/00_shared_space_ecolgen/raw_sequencing_data/RNA_shortread/2024_10_rnaseq_for_annotations_ConAdapt/extracted/X201SC23113328-Z01-F009/01.RawData/XN* .

# check MD5 sums
for folder in XN*
do
cd $folder
md5sum -c MD5.txt
cd ..
done
```

### Downloading published RNAseq data
Data are from:
Bočaj, Valentina, Paula Pongrac, Sina Fischer, and Matevž Likar. “De Novo Transcriptome Assembly of Hyperaccumulating Noccaea Praecox for Gene Discovery.” Scientific Data 10, no. 1 (December 1, 2023): 856. https://doi.org/10.1038/s41597-023-02776-x.

Download links from:
https://www.ebi.ac.uk/ena/browser/view/PRJNA984443

```{sh}
mkdir Bocaj_et_al_2023

```


```{sh}
### Script for Metacentrum

#PBS -N Download_from_ENA
#PBS -l select=1:ncpus=1:mem=8gb:scratch_local=10gb:brno=True
#PBS -l walltime=24:00:00 
#PBS -m ae
# I ask for machine in Brno, because it is close to storage and the data transfer might be faster.

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/1_raw_reads/Bocaj_et_al_2023

echo "Download start"  | ts '[%Y-%m-%d %H:%M:%S]'

# -nv option to disable progress bar
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/066/SRR24947466/SRR24947466_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/061/SRR24947461/SRR24947461_2.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/061/SRR24947461/SRR24947461_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/062/SRR24947462/SRR24947462_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/065/SRR24947465/SRR24947465_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/063/SRR24947463/SRR24947463_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/064/SRR24947464/SRR24947464_1.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/062/SRR24947462/SRR24947462_2.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/066/SRR24947466/SRR24947466_2.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/063/SRR24947463/SRR24947463_2.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/064/SRR24947464/SRR24947464_2.fastq.gz
wget -nv ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR249/065/SRR24947465/SRR24947465_2.fastq.gz

echo "Download done"  | ts '[%Y-%m-%d %H:%M:%S]'

md5sum * > md5_to_check.txt

echo "md5sum done"  | ts '[%Y-%m-%d %H:%M:%S]'


# clean the SCRATCH directory
clean_scratch
```



```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/metacentrum_scripts
qsub Download_from_ENA.sh
```
md5sum checked, it matches the one on ENA website.


### Script to run both FastQC and MultiQC on RNAseq data
```{sh}
#!/bin/bash
#PBS -N FastQC_RNAseq
#PBS -l select=1:ncpus=10:mem=96gb:scratch_local=10gb
#PBS -l walltime=2:00:00
#PBS -j oe

trap 'clean_scratch' TERM EXIT

# define a DATADIR variable: directory where the input files are taken from
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/1_raw_reads
# directory for output
OUTDIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/1_raw_reads
# report name
report_name="Noccaea_RNAseq_MultiQC_report"

# create the fastqc dir if it does not exists
if [ ! -d $OUTDIR/fastqc ]; then 
mkdir $OUTDIR/fastqc
fi

# create the multiqc dir if it does not exists
if [ ! -d $OUTDIR/multiqc ]; then
mkdir $OUTDIR/multiqc
fi

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
#test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# load Java
module add openjdk/

# FastQC run

# Version 1 for files in multiple folders
time find $DATADIR -type f \( -iname "*.fastq.gz" -o -iname "*.fq.gz" \) -print0 | xargs -0 /storage/brno12-cerit/home/duchmil/SW/fastqc/FastQC/fastqc -t 10 -o $OUTDIR/fastqc -f fastq

# Version 2 for files in single folder (not going to subfolders)
# time /storage/brno12-cerit/home/duchmil/SW/fastqc/FastQC/fastqc -t 10 -o $OUTDIR/fastqc -f fastq $DATADIR/*.fastq.gz


# Running MultiQC
# activation
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate Multiqc

# run MultiQC
time multiqc --filename $report_name --outdir $OUTDIR/multiqc $OUTDIR/fastqc

# Resources: 23 min, 88 GB memory, 62 % CPU for 22 files, some of them quite big.
```


```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/metacentrum_scripts
qsub run_fastqc_multiqc_Milos_RNAseq.sh
```

#### Result of FastQC
Our RNAseq files (XN580...) have 16-20 M reads (each from the pair). The Bocaj_et_al_2023 files have 100-124 M reads, but the quality seems to be lower. Some of the Bocaj files have strange curve of "Per Sequence GC Content", our files have nice curves without any shoulders. Our files doesn't have any overrepresented sequences.
There are almost any adapters in none of the files, so the trimming is probably not needed. But I will do that to keep the pipeline same.


### Trimming
Trimming based on quality, removal of the adaptors.
Adaptors are there only in case that the insert is too short and it is read through. It means that they are usually at the 3' terminus.
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/
mkdir 2_trimmed_reads
```

Trimming and FastQC and MultiQC after trimming
```{sh}
### Script for Metacentrum

#PBS -N trim_galore_for_RNAseq
#PBS -l select=1:ncpus=4:mem=20gb:scratch_local=10gb:brno=True
#PBS -l walltime=24:00:00 
#PBS -m ae

## trim_galore

# define a DATADIR variable: directory where the input files are taken from
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/1_raw_reads
# directory for output
OUTDIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/2_trimmed_reads

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" >> $PBS_O_WORKDIR/jobs_info.txt

# move into data directory
cd $DATADIR

# running trim_galore
module load trim_galore/0.6.2_py3
trim_galore --version # version 0.6.2

# There is needed "sort" because the manual says:
# "Trim Galore! expects paired-end files to be supplied in a pairwise fashion, e.g. file1_1.fq file1_2.fq SRR2_1.fq.gz SRR2_2.fq.gz ... ."
time find $DATADIR -type f \( -iname "*.fastq.gz" -o -iname "*.fq.gz" \) | sort | xargs trim_galore --paired --cores 4 -o $OUTDIR

# Remove trim_galore module
# The MultiQC otherwise does not work.
module remove trim_galore/0.6.2_py3

## FastQC and MultiQC after trim_galore

#### Files after trim_galore trimming end with *.fq.gz and not *.fastq.gz!

# report name
report_name="Noccaea_RNAseq_MultiQC_report_after_trimming"

# create the fastqc dir if it does not exists
if [ ! -d $OUTDIR/fastqc ]; then 
mkdir $OUTDIR/fastqc
fi

# create the multiqc dir if it does not exists
if [ ! -d $OUTDIR/multiqc ]; then
mkdir $OUTDIR/multiqc
fi

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
#test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# load Java
module add openjdk/

# FastQC run

# Version 1 for files in multiple folders
# time find $DATADIR -type f \( -iname "*.fastq.gz" -o -iname "*.fq.gz" \) -print0 | xargs -0 /storage/brno12-cerit/home/duchmil/SW/fastqc/FastQC/fastqc -t 10 -o $OUTDIR/fastqc -f fastq

# Version 2 for files in single folder (not going to subfolders)
time /storage/brno12-cerit/home/duchmil/SW/fastqc/FastQC/fastqc -t 4 -o $OUTDIR/fastqc -f fastq $OUTDIR/*.fq.gz


# Running MultiQC
# activation
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate Multiqc

# run MultiQC
time multiqc --filename $report_name --outdir $OUTDIR/multiqc $OUTDIR/fastqc

# clean the SCRATCH directory
clean_scratch

# Resources: 6 h 20 min, 97 % CPU, 100 % memory.
```

Checking trimming reports
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/2_trimmed_reads
grep 'Reads with adapters:' *trimming_report.txt # 34-44 %
grep 'Total written (filtered):' *trimming_report.txt # over 99 %
```

MultiQC report:
I don't see any difference from the previous report. Just a bit with sequence length.


## Alignment of RNAseq reads with HISAT2
Braker instructions (https://github.com/Gaius-Augustus/BRAKER#braker-with-rna-seq-and-protein-data):
"GeneMark-ETP utilizes Stringtie2 to assemble RNA-Seq data, which requires that the aligned reads (BAM files) contain the XS (strand) tag for spliced reads. Therefore, if you align your reads with HISAT2, you must enable the --dta option."

HISAT2 manual
http://daehwankimlab.github.io/hisat2/manual/



Folder for results
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq
mkdir 3_aligned_reads
```

### Running mapping with Hisat2
Conversion to bam, sorting, indexing and merging of the bam and indexing of the merged bam using samtools is included in the script.

Test
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/2_trimmed_reads
find . -type f -name "*_2_val_2.fq.gz" | sort | sed 's,./,,' | sed 's,_2_val_2.fq.gz,,' | while read my_sample
do
echo $my_sample
done
```


```{sh}
### Script for Metacentrum

#PBS -N hisat2_alignment_RNAseq
#PBS -l select=1:ncpus=32:mem=128gb:scratch_local=500gb
#PBS -l walltime=24:00:00 
#PBS -m ae


# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12
# assembly name
ASSEMBLY=Noccaea_polished_2024_10_Mahnaz.masked.fa

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# loading modules needed
module load hisat2
hisat2 --version
module load samtools
samtools --version

echo "Modules loaded" | ts '[%Y-%m-%d %H:%M:%S]'


# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy reference genome
cp -v -r $DATADIR/genome_assembly/$ASSEMBLY $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

# copy RNAseq files
cp -v -r $DATADIR/rnaseq/2_trimmed_reads/*.fq.gz $SCRATCHDIR || { echo >&2 "Error while copying fastq file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# move into scratch directory
cd $SCRATCHDIR

# Build the index of reference sequence
hisat2-build -f -p 32 $ASSEMBLY hisat2_index

echo "Hisat2 index done." | ts '[%Y-%m-%d %H:%M:%S]'

# running HISAT2
find . -type f -name "*_2_val_2.fq.gz" | sort | sed 's,./,,' | sed 's,_2_val_2.fq.gz,,' | while read my_sample
do
  hisat2 -q -t --dta -p 32 -x hisat2_index \
   -1  $my_sample"_1_val_1.fq.gz"\
   -2  $my_sample"_2_val_2.fq.gz"\
   -S $my_sample"_trimmed.sam" | ts '[%Y-%m-%d %H:%M:%S]'
   
  echo "Alignment for $my_sample done." | ts '[%Y-%m-%d %H:%M:%S]'
  
  # conversion to bam 
  samtools view -bS --threads 32 $my_sample"_trimmed.sam" > $my_sample"_trimmed.bam"
  # sorting of bam
  samtools sort --threads 32 $my_sample"_trimmed.bam" -o $my_sample"_trimmed_sorted.bam"
  # indexing of bam
  samtools index -@ 32 $my_sample"_trimmed_sorted.bam"
  
  echo "Samtools conversion to bam, sorting and indexing for $my_sample done." | ts '[%Y-%m-%d %H:%M:%S]'
  
  # move the output to user's DATADIR or exit in case of failure
  cp -v $my_sample"_trimmed_sorted.bam" $DATADIR/rnaseq/3_aligned_reads/ || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }
  cp -v $my_sample"_trimmed_sorted.bam.bai" $DATADIR/rnaseq/3_aligned_reads/ || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }
  
  echo "Copying output files for $my_sample done." | ts '[%Y-%m-%d %H:%M:%S]'

done

# Merging of bams
samtools merge -@ 32 -o RNAseq_trimmed_merged.bam *_trimmed_sorted.bam
# indexing of merged bam
samtools index -@ 32 RNAseq_trimmed_merged.bam
cp -v RNAseq_trimmed_merged.bam* $DATADIR/rnaseq/3_aligned_reads/ || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Merging of bams done." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch

# Resources: 6 h, 65 % CPU, 100 % memory
```


### Checking logs
Output statistics: hisat2_alignment_RNAseq.e7807131
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/metacentrum_scripts
# Most important statistics
o_file=hisat2_alignment_RNAseq.o7807131
e_file=hisat2_alignment_RNAseq.e7807131
paste <(grep 'Alignment for ' $o_file | sed 's/^.*Alignment for //' | sed 's/ done.//') <(grep 'overall alignment rate' $e_file)  <(grep 'aligned concordantly exactly 1 time' $e_file) <(grep 'aligned concordantly >1 times' $e_file) | column -t | less -S


```
Noccaea

SRR24947461  62.94%  overall  alignment  rate  52688337  (52.47%)  aligned  concordantly  exactly  1  time  3947151   (3.93%)   aligned  concordantly  >1  times
SRR24947462  62.06%  overall  alignment  rate  65494606  (52.63%)  aligned  concordantly  exactly  1  time  3078652   (2.47%)   aligned  concordantly  >1  times
SRR24947463  57.88%  overall  alignment  rate  61563211  (50.41%)  aligned  concordantly  exactly  1  time  2530332   (2.07%)   aligned  concordantly  >1  times
SRR24947464  74.88%  overall  alignment  rate  75143196  (65.64%)  aligned  concordantly  exactly  1  time  3670500   (3.21%)   aligned  concordantly  >1  times
SRR24947465  78.91%  overall  alignment  rate  73881131  (69.84%)  aligned  concordantly  exactly  1  time  3821305   (3.61%)   aligned  concordantly  >1  times
SRR24947466  70.50%  overall  alignment  rate  59916569  (49.11%)  aligned  concordantly  exactly  1  time  20972725  (17.19%)  aligned  concordantly  >1  times
XN580_FB     80.79%  overall  alignment  rate  13836893  (68.56%)  aligned  concordantly  exactly  1  time  470979    (2.33%)   aligned  concordantly  >1  times
XN580_F      80.49%  overall  alignment  rate  11639449  (68.42%)  aligned  concordantly  exactly  1  time  416401    (2.45%)   aligned  concordantly  >1  times
XN580_L      81.19%  overall  alignment  rate  12380457  (68.45%)  aligned  concordantly  exactly  1  time  547587    (3.03%)   aligned  concordantly  >1  times
XN580_R      76.58%  overall  alignment  rate  11855116  (64.63%)  aligned  concordantly  exactly  1  time  390891    (2.13%)   aligned  concordantly  >1  times
XN580_S      80.39%  overall  alignment  rate  11335150  (68.29%)  aligned  concordantly  exactly  1  time  370158    (2.23%)   aligned  concordantly  >1  times


Alyssum

AM08M_CF        82.26% overall alignment rate       15395977 (72.53%) aligned concordantly exactly 1 time           1103653 (5.20%) aligned concordantly >1 times
AM08M_RO        80.78% overall alignment rate       14909449 (72.43%) aligned concordantly exactly 1 time           710062 (3.45%) aligned concordantly >1 times
AM08N_CF        75.13% overall alignment rate       13619900 (66.20%) aligned concordantly exactly 1 time           987032 (4.80%) aligned concordantly >1 times
AM08N_OF        68.77% overall alignment rate       12482837 (59.82%) aligned concordantly exactly 1 time           1164331 (5.58%) aligned concordantly >1 times
AM08N_OL        71.28% overall alignment rate       12701049 (59.93%) aligned concordantly exactly 1 time           1622373 (7.66%) aligned concordantly >1 times
AM08N_RO        75.34% overall alignment rate       13749781 (67.05%) aligned concordantly exactly 1 time           790056 (3.85%) aligned concordantly >1 times
AM08N_YL        69.47% overall alignment rate       12755339 (60.27%) aligned concordantly exactly 1 time           1153072 (5.45%) aligned concordantly >1 times




## Preparation of protein sequences

Protein sequences downloaded from https://bioinf.uni-greifswald.de/bioinf/partitioned_odb11/ (https://bioinf.uni-greifswald.de/bioinf/partitioned_odb11/Viridiplantae.fa.gz).
Protein sequences should be decompressed (it should be normal fasta).

```{sh}
# copying of OrthoDB Viridiplantae proteins used for Alyssum annotation to folder shared for all species
mkdir /storage/brno12-cerit/home/duchmil/annotations/OrthoDB_proteins
cp /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/protein_seqs_input/1_downloaded/Viridiplantae.fa /storage/brno12-cerit/home/duchmil/annotations/OrthoDB_proteins


# cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/
# mkdir protein_seqs_input
# cd protein_seqs_input
# mkdir 1_downloaded
# cd 1_downloaded
# wget https://bioinf.uni-greifswald.de/bioinf/partitioned_odb11/Viridiplantae.fa.gz
# gunzip Viridiplantae.fa.gz
```


## Installation of Braker

The Braker is already installed in `/storage/brno12-cerit/home/duchmil/SW/braker_sw`, where I copied that from Alyssum annotation folder.
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly
mkdir braker_sw
cd braker_sw

singularity build braker3.sif docker://teambraker/braker3:latest


# Run the tests
# (see https://github.com/Gaius-Augustus/BRAKER#container)
singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test1.sh .
singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test2.sh .
singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test3.sh .

# Interactive job for tests
qsub -I -l select=1:ncpus=2:mem=16gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/braker_sw

export BRAKER_SIF=/storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/braker_sw/braker3.sif

bash test1.sh
bash test2.sh
bash test3.sh

# In the end I ran the 3rd test as Metacentrum job:
qsub test3_for_Metacentrum.sh
# It ran 11 minutes.
```

Test of Braker in new location

```{sh}

# Interactive job for tests
qsub -I -l select=1:ncpus=2:mem=16gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/SW/braker_sw

export BRAKER_SIF=/storage/brno12-cerit/home/duchmil/SW/braker_sw/braker3.sif

bash test1.sh
# bash test2.sh
# bash test3.sh

# In the end I ran the 3rd test as Metacentrum job:
# qsub test3_for_Metacentrum.sh
# It ran 11 minutes.
```


# Running Braker



```{sh}
### Script for Metacentrum

#PBS -N braker_Noccaea_01
#PBS -l select=1:ncpus=16:mem=96gb:scratch_local=1000gb
#PBS -l walltime=48:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -r $DATADIR/rnaseq/3_aligned_reads/RNAseq_trimmed_merged.bam $SCRATCHDIR || { echo >&2 "Error while copying input file(s)!"; exit 2; }
cp -r /storage/brno12-cerit/home/duchmil/annotations/OrthoDB_proteins/Viridiplantae.fa $SCRATCHDIR || { echo >&2 "Error while copying input file(s)!"; exit 2; }
cp -r $DATADIR/genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa $SCRATCHDIR || { echo >&2 "Error while copying input file(s)!"; exit 2; }


# move into scratch directory
cd $SCRATCHDIR 
mkdir results_braker_01

# running BRAKER
export BRAKER_SIF=/storage/brno12-cerit/home/duchmil/SW/braker_sw/braker3.sif

singularity exec -B ${PWD}:${PWD} ${BRAKER_SIF} braker.pl --bam=RNAseq_trimmed_merged.bam --genome=Noccaea_polished_2024_10_Mahnaz.masked.fa --prot_seq=Viridiplantae.fa --threads=16 --species=Noccaea_praecox --workingdir=$SCRATCHDIR/results_braker_01
# Note: Protein sequences shouldn't be compressed. It should be plain fasta.


# move the output to user's DATADIR or exit in case of failure
cp -r results_braker_01 $DATADIR/ || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

# clean the SCRATCH directory
clean_scratch

# Resources: The job was running 9 h 40 min, using 100% memory and 36% of CPU time.
```





# Quality check of the Braker annotation

## Running IGV on Metacentrum
```{sh}
# Download IGV
wget https://data.broadinstitute.org/igv/projects/downloads/2.16/IGV_2.16.2.zip
# Unzip IGV
unzip IGV_2.16.2.zip
# Start interactive job
qsub -I -l select=1:ncpus=2:mem=32gb:scratch_local=40gb -l walltime=5:00:00
# load and start GUI
module add gui
gui start
# Open the URL in browser.
# Open terminal in GUI.
# Run these commands:
# load Java
module load openjdk
# run IGV
/storage/brno12-cerit/home/duchmil/SW/igv/IGV_2.16.2/igv.sh
```

## Number of genes
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/results_braker_01/
grep -c -P "\tgene\t" braker.gtf # 30373
```


## Checking proteins predicted by Braker for stop codons
```{sh}
# converting from folded fasta to unfolded fasta for better counting and counting internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < braker.aa | grep \*[[:alpha:]] | wc -l # 3

awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < braker.aa | grep -B1 '\*[[:alpha:]]'
```
There are 3 proteins with stop codons. Probably some frameshift in genome assembly? I should check that later.
Proteins with stop codons:
g7324.t1
g28145.t1
g30133.t1


## Alignment of protein sequences to the genome assembly
Miniprot
https://github.com/lh3/miniprot
The alignment of the proteins will be needed to check the annotation by Braker.

Generally proteins of closely related species with good annotation should be used.
We used protein sequences of B. rapa, A. thaliana and A. lyrata.

Data:
B. rapa web page: http://brassicadb.cn
http://39.100.233.196:82/download_genome/Brassica_Genome_data/Brara_Chiifu_V3.0/Brapa_genome_v3.0_pep.fasta.gz
http://39.100.233.196:82/download_genome/Brassica_Genome_data/Brara_Chiifu_V4.1/Brapa_chiifu_v41_gene20230413.gff3.pep.fa.gz
A. thaliana
https://www.arabidopsis.org/download/file?path=Proteins/Araport11_protein_lists/Araport11_pep_20220914.gz
A. lyrata NCBI 101 annotation
https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/004/255/GCF_000004255.2_v.1.0/GCF_000004255.2_v.1.0_protein.faa.gz


### Getting protein sequences
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/
mkdir protein_seqs_input
cd protein_seqs_input
mkdir 1_downloaded
cd 1_downloaded



# download protein sequences
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/protein_seqs_input/1_downloaded
wget http://39.100.233.196:82/download_genome/Brassica_Genome_data/Brara_Chiifu_V4.1/Brapa_chiifu_v41_gene20230413.gff3.pep.fa.gz

# this command does not work, I had to download it to my computer and then copy to Metacentrum
# wget "https://www.arabidopsis.org/download/file?path=Proteins/Araport11_protein_lists/Araport11_pep_20220914.gz"
# copy from Alyssum annotation
cp -v /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/protein_seqs_input/1_downloaded/Araport11_pep_20220914.gz .

wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/004/255/GCF_000004255.2_v.1.0/GCF_000004255.2_v.1.0_protein.faa.gz


# checking number of sequences
zgrep -c '>' Araport11_pep_20220914.gz # 48266
zgrep -c '>' Brapa_chiifu_v41_gene20230413.gff3.pep.fa.gz # 83470
zgrep -c '>' GCF_000004255.2_v.1.0_protein.faa.gz # 39161


# check stop codons
# converting from folded fasta to unfolded fasta for better counting and counting internal stop codons
zcat GCF_000004255.2_v.1.0_protein.faa.gz | awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' | grep \*[[:alpha:]] | wc -l # 0

# make folder for results
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/protein_seqs_input
mkdir 2_aligned
```


### Miniprot alignment
```{sh}
# download Miniprot and compile
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly
git clone https://github.com/lh3/miniprot
cd miniprot && make
```


```{sh}
### Script for Metacentrum

#PBS -N miniprot_alignment_01
#PBS -l select=1:ncpus=16:mem=16gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

MINIPROTDIR=/storage/brno12-cerit/home/duchmil/SW/miniprot

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -r $DATADIR/protein_seqs_input/1_downloaded/Araport11_pep_20220914.gz \
$DATADIR/protein_seqs_input/1_downloaded/Brapa_chiifu_v41_gene20230413.gff3.pep.fa.gz \
$DATADIR/protein_seqs_input/1_downloaded/GCF_000004255.2_v.1.0_protein.faa.gz \
$SCRATCHDIR || { echo >&2 "Error while copying input file(s)!"; exit 2; }

cp -r $DATADIR/genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa $SCRATCHDIR || { echo >&2 "Error while copying input file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 

# make index for miniprot
$MINIPROTDIR/miniprot -t16 -d miniprot_index.mpi Noccaea_polished_2024_10_Mahnaz.masked.fa

echo "Miniprot index prepared." | ts '[%Y-%m-%d %H:%M:%S]'

# running miniprot
$MINIPROTDIR/miniprot -Iut16 --gff miniprot_index.mpi Araport11_pep_20220914.gz > A.thaliana.pep.gff
echo "A. thaliana done." | ts '[%Y-%m-%d %H:%M:%S]'
$MINIPROTDIR/miniprot -Iut16 --gff miniprot_index.mpi Brapa_chiifu_v41_gene20230413.gff3.pep.fa.gz > B.rapa.pep.gff
echo "B. rapa done." | ts '[%Y-%m-%d %H:%M:%S]'
$MINIPROTDIR/miniprot -Iut16 --gff miniprot_index.mpi GCF_000004255.2_v.1.0_protein.faa.gz > A.lyrata.pep.gff
echo "A. lyrata done." | ts '[%Y-%m-%d %H:%M:%S]'




# move the output to user's DATADIR or exit in case of failure
cp -v *.gff $DATADIR/protein_seqs_input/2_aligned | ts '[%Y-%m-%d %H:%M:%S]' || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

# clean the SCRATCH directory
clean_scratch

# Resources: 4 min, 88 % CPU, only 5 GB memory
```

## Assembly of transcripts from RNAseq alignment

The assembled transcipts will be used to:
- check Braker annotation visually using IGV,
- extract sequences from them using AGAT and run Busco on them,
- check the overlaps of them with annotated genes.

stringtie to produce transcripts from aligned RNAseq reads
- default parameters should be fine
- set the number of threads

```{sh}
# Installing StringTie
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly
git clone https://github.com/gpertea/stringtie
cd stringtie
make release
# Main command for running StringTie (I ran in a script)
~/SW/stringtie/stringtie -p 16 -o Assembled_transcripts.gtf Alyssum_RNAseq_trimmed_merged.bam
```


```{sh}
# folder for results
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq
mkdir 4_assembled_transcripts
```


```{sh}
### Script for Metacentrum

#PBS -N stringtie_transcript_assembly
#PBS -l select=1:ncpus=4:mem=28gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq

STRINGTIEDIR=/storage/brno12-cerit/home/duchmil/SW/stringtie

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -rv $DATADIR/3_aligned_reads/RNAseq_trimmed_merged.bam* $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 


# running Stringtie
$STRINGTIEDIR/stringtie -p 4 -o Assembled_transcripts.gtf RNAseq_trimmed_merged.bam || { echo >&2 "Running of main command failed (with a code $?) !!"; exit 3; }

echo "Stringtie assembly done." | ts '[%Y-%m-%d %H:%M:%S]'

# move the output to user's DATADIR or exit in case of failure
cp -v Assembled_transcripts.gtf $DATADIR/4_assembled_transcripts || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Output files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch


# Note to computational resources:
# The script ran 26 min, with 24 % CPU time and 100% memory used. It seems like it is using only one CPU.
```

## Extraction of transcript sequences
Extracted transcript sequences will be used to run Busco on them.

### Installation of new version of AGAT
Older version (v0.6.0) is pre-installed as Mamba module in Metacentrum.
The installation through Conda/Mamba got stuck, so I used Singularity.
```{sh}
cd ~/SW
mkdir agat
cd agat
singularity pull docker://quay.io/biocontainers/agat:1.4.0--pl5321hdfd78af_0

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif
```

### Extraction of transcript (mRNA) sequences
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/rnaseq/4_assembled_transcripts

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# extraction of mRNA (UTRs + CDS)
agat_sp_extract_sequences.pl -g Assembled_transcripts.gtf -f /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa -t exon --merge -o Assembled_transcripts.fasta | tee log_transcripts_AGAT.txt

exit

# Number of transcripts
grep -P -c '\ttranscript\t' Assembled_transcripts.gtf # 57671
grep -c '>' Assembled_transcripts.fasta # 57671

# Counting of genes
grep -P '\ttranscript\t' Assembled_transcripts.gtf | cut -f 9 | sed 's/; transcript_id.*$//' | head -n 50
grep -P '\ttranscript\t' Assembled_transcripts.gtf | cut -f 9 | sed 's/; transcript_id.*$//' | sort | uniq | wc -l # 39004
grep -P '\ttranscript\t' Assembled_transcripts.gtf | cut -f 9 | sed 's/; transcript_id.*$//' | tail # the highest number is 39004
```



## Busco
### Busco installation
```{sh}
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate

conda create -n busco_5_7_1 -c conda-forge -c bioconda busco=5.7.1
conda activate busco_5_7_1
```

### Busco for proteins predicted by Braker
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/
mkdir busco_results
cd busco_results

source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

busco --list-datasets

# main command
busco --in ../results_braker_alyssum_01/braker.aa --mode proteins --lineage_dataset brassicales_odb10 --cpu 16
```


```{sh}
### Script for Metacentrum

#PBS -N Busco_Braker_proteins
#PBS -l select=1:ncpus=4:mem=8gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -v $DATADIR/results_braker_01/braker.aa $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 


# activate Busco
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

# run Busco
busco --in braker.aa --mode proteins --lineage_dataset brassicales_odb10 --cpu 4

echo "Main computation done." | ts '[%Y-%m-%d %H:%M:%S]'

# move the output to user's DATADIR or exit in case of failure
cp -vR BUSCO_* $DATADIR/busco_results || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Output files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch

# Resources: The script ran 16 min, with 24 % CPU time and 5 GB memory used.
```


### Busco for transcripts assembled from RNAseq
```{sh}
### Script for Metacentrum

#PBS -N Busco_transcripts
#PBS -l select=1:ncpus=4:mem=12gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -v $DATADIR/rnaseq/4_assembled_transcripts/Assembled_transcripts.fasta $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 


# activate Busco
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

# run Busco
busco --in Assembled_transcripts.fasta --mode transcriptome --lineage_dataset brassicales_odb10 --cpu 4

echo "Main computation done." | ts '[%Y-%m-%d %H:%M:%S]'

# move the output to user's DATADIR or exit in case of failure
cp -vR BUSCO_* $DATADIR/busco_results || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Output files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch

# Resources: The script ran 33 min, with 53 % CPU time and 8 GB memory used.
```

### Busco for genome
```{sh}
### Script for Metacentrum

#PBS -N Busco_genome
#PBS -l select=1:ncpus=2:mem=12gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -v $DATADIR/genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 


# activate Busco
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

# run Busco
busco --in Noccaea_polished_2024_10_Mahnaz.masked.fa --mode genome --lineage_dataset brassicales_odb10 --cpu 2

echo "Main computation done." | ts '[%Y-%m-%d %H:%M:%S]'

# move the output to user's DATADIR or exit in case of failure
cp -vR BUSCO_* $DATADIR/busco_results || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Output files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch

# Resources: The script ran 9 min, with 35 % CPU time and 9 GB memory used.
```

### Busco for CDS predicted by Braker
This is just to check the difference between protein and transcript mode of Busco.
```{sh}
### Script for Metacentrum

#PBS -N Busco_Braker_CDS
#PBS -l select=1:ncpus=4:mem=12gb:scratch_local=1000gb
#PBS -l walltime=2:00:00 
#PBS -m ae

# define a DATADIR variable: directory where the input files are taken from and where output will be copied to
DATADIR=/storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12

# append a line to a file "jobs_info.txt" containing the ID of the job, the hostname of node it is run on and the path to a scratch directory
# this information helps to find a scratch directory in case the job fails and you need to remove the scratch directory manually 
echo "$PBS_JOBID is running on node `hostname -f` in a scratch directory $SCRATCHDIR" | ts '[%Y-%m-%d %H:%M:%S]' >> $PBS_O_WORKDIR/jobs_info.txt

# test if scratch directory is set
# if scratch directory is not set, issue error message and exit
test -n "$SCRATCHDIR" || { echo >&2 "Variable SCRATCHDIR is not set!"; exit 1; }

# copy files
cp -v $DATADIR/results_braker_01/braker.codingseq $SCRATCHDIR || { echo >&2 "Error while copying index file(s)!"; exit 2; }

echo "Input files copied." | ts '[%Y-%m-%d %H:%M:%S]'


# move into scratch directory
cd $SCRATCHDIR 


# activate Busco
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

# run Busco
busco --in braker.codingseq --mode transcriptome --lineage_dataset brassicales_odb10 --cpu 4

echo "Main computation done." | ts '[%Y-%m-%d %H:%M:%S]'

# move the output to user's DATADIR or exit in case of failure
cp -vR BUSCO_* $DATADIR/busco_results || { echo >&2 "Result file(s) copying failed (with a code $?) !!"; exit 4; }

echo "Output files copied." | ts '[%Y-%m-%d %H:%M:%S]'

# clean the SCRATCH directory
clean_scratch

# Resources: The script ran 37 min, with 64 % CPU time and 5 GB memory used.
```

### Plot Busco results
```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/busco_results/

mkdir summaries_BUSCO

# copy summaries from all Busco results folders
find BUSCO* -name "short_summary.specific.*.txt" -exec cp {} summaries_BUSCO/ \;

# Rename some summaries (avoid dot in specific part of the name) so that Busco script will distinguish them
cd summaries_BUSCO/
mv short_summary.specific.brassicales_odb10.BUSCO_braker.aa.txt short_summary.specific.brassicales_odb10.BUSCO_braker_aa.txt
mv short_summary.specific.brassicales_odb10.BUSCO_braker.codingseq.txt short_summary.specific.brassicales_odb10.BUSCO_braker_codingseq.txt


# activate Busco
source /storage/brno2/home/duchmil/SW/mambaforge/bin/activate busco_5_7_1

# Use script to generate plot
generate_plot.py -wd .
```




### Busco results

#### Assembly

	C:99.2%[S:94.4%,D:4.8%],F:0.2%,M:0.6%,n:4596,E:1.8%	   
	4558	Complete BUSCOs (C)	(of which 83 contain internal stop codons)		   
	4337	Complete and single-copy BUSCOs (S)	   
	221	Complete and duplicated BUSCOs (D)	   
	11	Fragmented BUSCOs (F)			   
	27	Missing BUSCOs (M)			   
	4596	Total BUSCO groups searched		   
	
#### Transcripts (RNAseq reads aligned to genome and assembled to transcripts)

	C:89.0%[S:55.9%,D:33.1%],F:3.0%,M:8.0%,n:4596	   
	4090	Complete BUSCOs (C)			   
	2567	Complete and single-copy BUSCOs (S)	   
	1523	Complete and duplicated BUSCOs (D)	   
	136	Fragmented BUSCOs (F)			   
	370	Missing BUSCOs (M)			   
	4596	Total BUSCO groups searched		   
	
#### Annotation (proteins predicted by Braker)

	C:97.6%[S:82.4%,D:15.2%],F:0.3%,M:2.1%,n:4596	   
	4487	Complete BUSCOs (C)			   
	3787	Complete and single-copy BUSCOs (S)	   
	700	Complete and duplicated BUSCOs (D)	   
	12	Fragmented BUSCOs (F)			   
	97	Missing BUSCOs (M)			   
	4596	Total BUSCO groups searched		   
	
#### Annotation (CDS predicted by Braker)

	C:97.6%[S:82.6%,D:15.0%],F:0.3%,M:2.1%,n:4596	   
	4487	Complete BUSCOs (C)			   
	3796	Complete and single-copy BUSCOs (S)	   
	691	Complete and duplicated BUSCOs (D)	   
	12	Fragmented BUSCOs (F)			   
	97	Missing BUSCOs (M)			   
	4596	Total BUSCO groups searched		   

#### Comments to results
- All Busco results are a bit better compared to Alyssum.




## Intersect between gene models and aligned proteins
bedtools intersect
https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12
mkdir intersects
cd intersects

module load bedtools2/2.30.0-gcc-10.2.1-5acjqve

ls ../protein_seqs_input/2_aligned/

# Intersects with proteins from single species
bedtools intersect -a ../results_braker_01/braker.gtf -b ../protein_seqs_input/2_aligned/A.thaliana.pep.gff -u -f 0.9 -r > braker_annotation_x_A.thaliana.pep.gff_intersect.tab

bedtools intersect -a ../results_braker_01/braker.gtf -b ../protein_seqs_input/2_aligned/A.lyrata.pep.gff -u -f 0.9 -r > braker_annotation_x_A.lyrata.pep.gff_intersect.tab

bedtools intersect -a ../results_braker_01/braker.gtf -b ../protein_seqs_input/2_aligned/B.rapa.pep.gff -u -f 0.9 -r > braker_annotation_x_B.rapa.pep.gff_intersect.tab

# Intersect with all proteins together
bedtools intersect -a ../results_braker_01/braker.gtf -b ../protein_seqs_input/2_aligned/*  -u -f 0.9 -r > braker_annotation_x_all.pep.gff_intersect.tab

```
This command finds the intersects between Braker output (`-a`) and at least one of the aligned proteins (files in `-b`).
It will report the genes in `-a` only once (option `-u`). The overlap should be at least 90 % (`-f 0.9`) for both `-a` and `-b` (option `-r` as reciprocal). 

Checking the outputs
```{sh}
grep -P -c "\tgene\t" ../results_braker_01/braker.gtf # 30373
grep -P -c "\tmRNA\t" ../protein_seqs_input/2_aligned/A.thaliana.pep.gff # 50164
grep -P -c "\tgene\t" braker_annotation_x_A.thaliana.pep.gff_intersect.tab # 18949

for FILE in braker_annotation_x_*
do
COUNT=$(grep -P -c "\tgene\t" $FILE)
echo "$FILE $COUNT"
done

```
Noccaea:
braker_annotation_x_A.lyrata.pep.gff_intersect.tab 19105
braker_annotation_x_A.thaliana.pep.gff_intersect.tab 18949
braker_annotation_x_B.rapa.pep.gff_intersect.tab 17914
braker_annotation_x_all.pep.gff_intersect.tab 20757


Alyssum:
braker_annotation_x_A.alpina.pep.gff_intersect.tab 16637
braker_annotation_x_A.lyrata.pep.gff_intersect.tab 18772
braker_annotation_x_A.saxatilis.pep.gff_intersect.tab 17095
braker_annotation_x_A.thaliana.pep.gff_intersect.tab 18676
braker_annotation_x_B.rapa.pep.gff_intersect.tab 17642
braker_annotation_x_all.pep.gff_intersect.tab 21660

Comment:
The intersects for Noccaea are higher than for Alyssum.









## Intersect between gene models and assembled transcripts
Again bedtools intersect.
This time we do not use the `-r` option - the overlap should be at least 90 % of Braker output, but not necesarilly of the Stringtie output. It is because the Stringtie tries to predict whole transcripts including UTRs.

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/intersects

module load bedtools2/2.30.0-gcc-10.2.1-5acjqve

ls ../rnaseq/4_assembled_transcripts/

# Intersects with Stringtie assembled transcripts
bedtools intersect -a ../results_braker_01/braker.gtf -b ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf -u -f 0.9 > braker_annotation_x_Assembled_transcripts.gtf_intersect.tab

# Number of genes predicted by Braker
grep -P -c "\tgene\t" ../results_braker_01/braker.gtf # 30373
# Number of transcripts assembled from RNAseq
grep -P -c "\ttranscript\t" ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf # 57671
# Number of genes assembled from RNAseq
# (Gene features are not annotated separately by StringTie, but there is a field gene_id for stranscripts which can be used.)
grep -P "\ttranscript\t" ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf | sed -E 's/.*\tgene_id//' | sed -E 's/; transcript_id.*//' | sort -u | wc -l # 39004
# Intersect of genes predicted by Braker and transcripts assembled from RNAseq
grep -P -c "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab # 21454


# intersect between two intersects: (1) intersect between annotation and protein alignments and (2) intersect between annotation and transcripts
bedtools intersect -a braker_annotation_x_Assembled_transcripts.gtf_intersect.tab -b braker_annotation_x_all.pep.gff_intersect.tab -u -f 1.0 -r > braker_transcript_and_braker_protein_meta_intersect.tab
grep -P -c "\tgene\t" braker_transcript_and_braker_protein_meta_intersect.tab # 17177
# There should be '-f 1.0', because we are comparing genes, mRNAs and exons from the same Braker prediction. If there is 0.9, the number of genes is slightly higher than it should be, because it probably takes also some intersects of genes with transcripts or something like that.

# Alternative way to calculate number of genes in intersect of intersects (metaintersect):
comm -12 <(grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9 | sort -u) <(grep -P "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab | cut -f 9 | sort -u) | wc -l # 17177
```

We will rather take union of the two intersects than the intersect of them as the "confident" set of gene models.
These will be gene models that are either supported by RNAseq reads (more precisely assembled transcripts) or by proteins from related species.


## Getting the list of "reliable" genes
Genes that are either supported by RNAseq reads (more precisely assembled transcripts) or by proteins from related species.
```{sh}
# checks
grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9 | sort | head -n 20
grep -P "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab | cut -f 9 | sort | head -n 20

cat <(grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9) <(grep -P "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab | cut -f 9) | sort -u | head -n 20

cat <(grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9) <(grep -P "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab | cut -f 9) | sort -u | wc -l

# List of reliable genes (union)
cat <(grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9) <(grep -P "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab | cut -f 9) | sort -u > reliable_genes.txt

wc -l reliable_genes.txt # 25034


```

## Move this old version of intersect files

In the end of this script, I use new version of intersect files, from which I make "reliability table".

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/intersects

mkdir -p intersects_old_version
mv -t ./intersects_old_version *
```

Recapitulation of results:
Genes predicted by Braker                                                                              30373
Genes predicted by Braker supported by aligned proteins                                                20757
Genes predicted by Braker supported by transcripts assembled from RNAseq                               21454
Genes predicted by Braker supported by both aligned proteins and transcripts assembled from RNAseq     17177
Genes predicted by Braker supported by either aligned proteins or transcripts assembled from RNAseq    25034


## Statistics of annotation using AGAT
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/
mkdir stat_annotation
cd stat_annotation

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# basic statistics
agat_sq_stat_basic.pl -i ../results_braker_01/braker.gtf -g ../genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa > stat_basic_braker.gtf.txt

# detailed statistics
agat_sp_statistics.pl -i ../results_braker_01/braker.gtf -g ../genome_assembly/Noccaea_polished_2024_10_Mahnaz.masked.fa > stat_detailed_braker.gtf.txt

```


# Removing genes with internal stop codons

## Conversion of Braker GTF to GFF
There should be script for conversion in Augustus, but it seems that it does not work well (https://github.com/Gaius-Augustus/BRAKER/issues/275). Thus, I will rather use AGAT.

This is not needed as I will use the original gtf as input for removal of genes with internal stop codons.
```{sh}
# # interactive job
# qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00
# 
# cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/
# mkdir annot_processing
# cd annot_processing
# 
# # run the container
# singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif
# 
# agat_convert_sp_gxf2gxf.pl --gff ../results_braker_01/braker.gtf -o braker.gff
```

## Remove genes with internal stop codons

Sometimes there are several genes with internal stop codons. These genes come always from "GeneMark.hmm3".

There is a script "fix_in_frame_stop_codon_genes.py" that should take care of this, but according to the log this script is used only for the Augustus output, before Tsebra combines it with the GeneMark output. So, if some GeneMark gene models contain internal stop codons, they might be retained in the final gene set.

```{sh}
mkdir -p /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing

# converting from folded fasta to unfolded fasta for better counting and counting internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < ../results_braker_01/braker.aa | grep \*[[:alpha:]] | wc -l
# check the genes
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < ../results_braker_01/braker.aa | grep -B1 '\*[[:alpha:]]'
# Make a list of the genes with internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < ../results_braker_01/braker.aa | grep -B1 '\*[[:alpha:]]' | grep '^>' | sed -E 's/>|\.t[0-9]+//g' > genes_with_internal_stop_codons.txt
# check the file
wc -l genes_with_internal_stop_codons.txt

# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing

# run the AGAT container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif
# Remove genes with internal stop codons based on list
agat_sp_filter_feature_from_kill_list.pl --gff ../results_braker_01/braker.gtf --kill_list genes_with_internal_stop_codons.txt -o braker_without_genes_with_internal_stop_codons.gff


## checks
# genes to be removed
wc -l genes_with_internal_stop_codons.txt
# original file
grep -P -c "\tgene\t" ../results_braker_01/braker.gtf
grep -P -c "\ttranscript\t" ../results_braker_01/braker.gtf 
# file without bad proteins
grep -P -c "\tgene\t" braker_without_genes_with_internal_stop_codons.gff 
grep -P -c "\ttranscript\t" braker_without_genes_with_internal_stop_codons.gff 
```


# Adding unknown expressed features
Bedtools subtract
https://bedtools.readthedocs.io/en/latest/content/tools/subtract.html
I will use -A option to get only transcripts with no overlap with Braker annotation.

### Note for future
Some tools used to annotate noncoding genes in A. thaliana genomes are descibed in this publication:

Lian, Qichao, Bruno Huettel, Birgit Walkemeier, Baptiste Mayjonade, Céline Lopez-Roques, Lisa Gil, Fabrice Roux, Korbinian Schneeberger, and Raphael Mercier. “A Pan-Genome of 69 Arabidopsis Thaliana Accessions Reveals a Conserved Genome Structure throughout the Global Species Range.” Nature Genetics 56, no. 5 (May 2024): 982–91. https://doi.org/10.1038/s41588-024-01715-9.

It might be good to try them.




```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing


module load bedtools2/2.30.0-gcc-10.2.1-5acjqve

ls ../rnaseq/4_assembled_transcripts/

# Get assembled transcripts with no overlap with Braker annotation. I will use them as unknown expressed features.
bedtools subtract -a ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf -b  braker_without_genes_with_internal_stop_codons.gff -A > Assembled_transcripts_with_no_annotation_overlap.gtf

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap.gtf # 17432

# There are also exons without parental transcripts (when only part of the transcript overlaps with annotation). I will have to remove them.

# make a keep list with IDs of transcripts
grep -P "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap.gtf | sed -E 's/(^.*; transcript_id ")|("; cov.*$)//g' > Assembled_transcripts_with_no_annotation_overlap.txt

wc -l Assembled_transcripts_with_no_annotation_overlap.txt # 17432

### Filtering assembled transcripts based on keep list
# This should ensure that there will be no orphan exons.

# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing


# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# Filter based on keep list and convert to GFF
agat_sp_filter_feature_from_keep_list.pl --type transcript,RNA --gff Assembled_transcripts_with_no_annotation_overlap.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_almost_clean.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_almost_clean.gff # 17432
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_almost_clean.gff # 507
# For genes where some transcripts overlap with Braker annotation and some not, sometimes the overlapping exons are kept by AGAT and are asigned a RNA feature. I will need to remove them in following steps.

# Make a kill list of IDs of RNA features that I want to remove.
grep -P "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_almost_clean.gff | sed -E 's/^.*;transcript_id=//g' > transcript_kill_list.txt

agat_sp_filter_feature_from_kill_list.pl --gff Assembled_transcripts_with_no_annotation_overlap_almost_clean.gff --kill_list transcript_kill_list.txt -o Assembled_transcripts_with_no_annotation_overlap_clean.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff # 17432
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff # 0
# Now the RNA features and their exons should be removed, there shouldn't be any transcripts overlapping with Braker annotation.



```




## Merging annotations
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing


# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# Complement annotations
# The file with unknown expressed features will be used as a reference, so the header of this file will be kept.
agat_sp_complement_annotations.pl --ref Assembled_transcripts_with_no_annotation_overlap_clean.gff --add braker_without_genes_with_internal_stop_codons.gff -o merged_annotation_01.gff

grep -P -c "\tgene\t" merged_annotation_01.gff # 44117
grep -P -c "\ttranscript\t" merged_annotation_01.gff # 51354
grep -P -c "\tRNA\t" merged_annotation_01.gff # 0
grep -P -c "\tmRNA\t" merged_annotation_01.gff # 2188


# Check numbers of lines (without header)
grep -P -v -c "^#" braker_without_genes_with_internal_stop_codons.gff # 586692
grep -P -v -c "^#" Assembled_transcripts_with_no_annotation_overlap_clean.gff # 73977
grep -P -v -c "^#" merged_annotation_01.gff # 660669

```

```{r}
# Check whether the number of lines of merged annotation is sum of the files that were merged
586692 + 73977 == 660669 # TRUE
```






# Changing IDs in R


```{r}
setwd("D:/!ecolgen/annotations/Noccaea_praecox_2024_12")

# read the gff file
gff.1 <- read.table(file = "annot_processing/merged_annotation_01.gff", header = F, sep = "\t", comment.char = "#" 
                     #, nrows = 1500
                    )
summary(gff.1)
head(gff.1)
gff.1[1:50, ]
```

### What feature types are there?

```{r}
# Types of features
levels(as.factor(gff.1$V3))
table(as.factor(gff.1$V3))

# scaffold names
levels(as.factor(gff.1$V1))
```

```{r}
## Changes in column 3

# mRNA is there only for genes predicted by GeneMark.hmm3
gff.1[grepl(pattern = "mRNA|transcript", x = gff.1$V3), ][1:40, ]
# It seems that mRNA is redundant with transcript
gff.1[grepl(pattern = "mRNA|transcript", x = gff.1$V3) & grepl(pattern = "GeneMark.hmm3", x = gff.1$V2), ][1:40, ]
# It doesn't have any childs features.
gff.1[grepl(pattern = "GeneMark.hmm3", x = gff.1$V2), ][1:40, ]

# I will remove mRNA features.
gff.2 <- gff.1[gff.1$V3 != "mRNA", ]
dim(gff.1)
dim(gff.2)


## Changes in column 2

table(as.factor(gff.1$V2))
table(as.factor(gff.1$V2), as.factor(gff.1$V3))


# Genes added by AGAT to assembled transcript - change col 2 to "StringTie"
gff.2[gff.2[, 2] == "AGAT", 2] <- "StringTie"

# Add "BRAKER" before other sources
gff.2$V2[gff.2$V2 %in% c("AUGUSTUS", "GeneMark.hmm3", "gmst")] <- paste0("BRAKER-", gff.2$V2[gff.2$V2 %in% c("AUGUSTUS", "GeneMark.hmm3", "gmst")])

## other changes

# For features "gene", remove cov, fPKM, tPM and transcript_id, because AGAT copied it just from the first transcript
gff.2[grepl(pattern = "gene", x = gff.2$V3), 9][1:40]
gff.2[grepl(pattern = "gene", x = gff.2$V3) & gff.2$V2 == "StringTie", 9][1:40]
# For some genes, there is also "exon_number", which I will also remove.
gff.2[grepl(pattern = "STRG.378", x = gff.2$V9), ][1:40, ]
gff.1[grepl(pattern = "STRG.1415", x = gff.2$V9), ][1:40, ]

gene.col9.1 <- gff.2[grepl(pattern = "gene", x = gff.2$V3) & gff.2$V2 == "StringTie", 9]
gene.col9.2 <- gsub(pattern = ";*cov=[0-9.]+;*", replacement = ";", x = gene.col9.1)
gene.col9.3 <- gsub(pattern = ";*fPKM=[0-9.]+;*", replacement = ";", x = gene.col9.2)
gene.col9.4 <- gsub(pattern = ";*tPM=[0-9.]+;*", replacement = ";", x = gene.col9.3)
gene.col9.5 <- gsub(pattern = ";*exon_number=[0-9.]+;*", replacement = ";", x = gene.col9.4)
gene.col9.6 <- gsub(pattern = ";*transcript_id=STRG[0-9.]+;*", replacement = "", x = gene.col9.5)
gene.col9.7 <- gsub(pattern = ";*gene_id=STRG[0-9.]+;*", replacement = "", x = gene.col9.6)
gff.2[grepl(pattern = "gene", x = gff.2$V3) & gff.2$V2 == "StringTie", 9] <- gene.col9.7
```

### Changing IDs
```{r}


# old gene names
old.genes <- gsub(pattern = "ID=|;gene_id.*$", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V9"])
scaff.genes <- as.integer(gsub(pattern = "scaffold_", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V1"]))
levels(as.factor(scaff.genes))

# New gene names with species code and readable ID
# use protein.coding.genes saved when assigning new IDs to protein coding genes
new.genes <- paste0("Np", formatC(x = scaff.genes, width = 3, flag = "0"), "G", formatC(x = 1:length(old.genes), width = 5, flag = "0"), "0")

# Checking if all gene names have the same length
table(nchar(new.genes))

genes <- cbind.data.frame(old.genes, new.genes, scaff.genes)
head(genes)
tail(genes)


# Row numbers where data for one gene begin and end are needed (see the loop below)
# GFF needs to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene).
genes$rows <- grep(pattern = "gene", x = gff.2$V3)
genes$end.rows <- NA
genes$end.rows[1:(nrow(genes)-1)] <- genes$rows[2:nrow(genes)]-1
genes$end.rows[nrow(genes)] <- nrow(gff.2)
tail(genes)

# New gff
gff.3 <- gff.2

## Loop to make new feature ids in GFF

# Gene names will be changed to new ones.
# Transcript names will be in the form gene_name.t1.
# Other features ("exon", "intron", "cds", "start_codon", "stop_codon") will have IDs in form "exon-AM_transcript_id-1", where the last number will count exons in that particular transcript.

# Warning:
# This loops expect the GFF to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene, the same should be valid for transcripts of one gene). First, I tried to make it more universal, but it was always searching for the rows for one gene using grep, which was slow like a hell.

i=1
i=5

for(i in 1:nrow(genes)) {
  # Extract rows for one gene and its subfeatures.
  descr1 <- gff.2[genes$rows[i]:genes$end.rows[i], "V9"]
  
  # Change the old gene ID for new gene ID
  descr2 <- gsub(pattern = genes$old.genes[i], 
                 replacement = genes$new.genes[i], 
                 x = descr1)
  
  # For stringtie assembled transcripts, add "t" to make the transcript ID in form "Np001G0000100.t1"
  descr2 <- gsub(pattern = paste0("(", genes$new.genes[i], "\\.)([[:digit:]]+)"), 
                 replacement = "\\1t\\2", 
                 x = descr2)
  
  # # Patterns defining how to find old gene name within different context.
  # patterns <- c(paste0("=", genes$old.genes[i], ";"),
  #               paste0("=", genes$old.genes[i], "\\.t"),
  #               paste0("=", genes$old.genes[i], "$")#,
  #               #"ID=agat-exon-[[:digit:]]+;"
  #               )
  # 
  # # Strings defining what to exchange the previous patterns for
  # replacements <- c(paste0("=", genes$new.genes[i], ";"),
  #                       paste0("=", genes$new.genes[i], ".t"),
  #                       paste0("=", genes$new.genes[i])#,
  #                   #paste0("ID=exon-", genes$new.genes[i], "-#;")
  #                   )
  # 
  # descr2 <- descr1
  # 
  # # Loop exchanging patterns for replacements
  # for(j in 1:length(patterns)) {
  #   descr2 <- gsub(pattern = patterns[j], 
  #                replacement = replacements[j], 
  #                x = descr2)
  # }
  # 
  # Loop to change IDs of features other than genes or transcripts
  for(feature in c("exon", "intron", "cds", "start_codon", "stop_codon")) {
    # Extract rows for one feature
    extr.feature <- descr2[grep(pattern = paste0("ID=(agat|IDmodified)-", feature, "-[[:digit:]]+;"), x = descr2)]
    # For some genes, there are no introns and it would make mess if we try to exchange something
    if(length(extr.feature) > 0) {
      # Transcript IDs
      transcripts <- gsub(pattern = ".*transcript_id=", replacement = "", x = extr.feature)
      # Sequence of numbers for features within transcript and gene (1 to n for every transcript)
      # feat.numbers <- unlist(mapply(seq, from = 1, to = table(transcripts))) # this doesn't work if the exons or other features are not in alphabetical order
      feat.numbers <- ave(x = seq_along(transcripts), transcripts, FUN = seq_along)
      # Modify the feature IDs
      mod.feature <- mapply(sub, 
                            pattern = paste0("ID=(agat|IDmodified)-", feature, "-[[:digit:]]+;"), 
                            replacement = paste0("ID=", feature, "-", transcripts, "-", feat.numbers, ";"), 
                            x = extr.feature, USE.NAMES = F)
      # Replace rows with modified ones
      descr2[grep(pattern = paste0("ID=(agat|IDmodified)-", feature, "-[[:digit:]]+;"), x = descr2)] <- mod.feature
    }
  }
  
  # Replace info in column 9 of GFF for the modified one
  gff.3[genes$rows[i]:genes$end.rows[i], "V9"] <- descr2
  # grep version (slow)
  # gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"] <- descr2
  
  # For every 100 genes, print the counting
  if(i %% 100 == 0) print(paste(i, "genes out of", nrow(genes), "done"))
  # i=i+1
}


tail(gff.3, n = 40)
# tail(gff.3, n = 100)
# 
# gff.3[grep(pattern = "=g365(;|\\.t|$)", x = gff.2$V9), ] 
#   
# i=1
# i=2


gff.4 <- gff.3

# Changing feature names
gff.4$V3[gff.4$V3 == "gene" & gff.4$V2 == "StringTie"] <- "ncRNA_gene"
gff.4$V3[gff.4$V3 == "transcript" & gff.4$V2 == "StringTie"] <- "ncRNA"



levels(as.factor(gff.4$V3))
table(gff.4$V3)




# read the header of gff file
gff.raw <- readLines(con = "annot_processing/merged_annotation_01.gff" 
                     , n = 1500
                    )
gff.header <- gff.raw[grep(pattern = "^#", x = gff.raw)]

# new header with new date
gff.header.3 <- c("##gff-version 3",
                  "# Noccaea praecox genome annotation",
                  "# Version 1.1",
                  "# 2025-10-16",
                  "#",
                  "# Version history",
                  "#",
                  "# Version 1.1 (2025-10-16)",
                  "# - Removed 3 genes predicted by Braker with internal stop codons.",
                  "# - Because of this, there are two more ncRNA_genes.",
                  "# - The genome assembly was renamed, but it is the same as for version 1.",
                  "# - Gene IDs were shortened (one zero was removed from the end).",
                  "# - Beware that also the other part of gene IDs might not correspond to previous version.",
                  "#",
                  "# Version 1 (2024-12-30)",
                  "# - Initial version",
                  "#",
                  "# Genome assembly",
                  "#",
                  "# File Noccaea_praecox_CUNI_V1_2024_10_masked.fa",
                  "# # contigs (>= 0 bp)         49",
                  "# # contigs (>= 1000 bp)      49",
                  "# # contigs (>= 5000 bp)      49",
                  "# # contigs (>= 10000 bp)     49",
                  "# # contigs (>= 25000 bp)     49",
                  "# # contigs (>= 50000 bp)     44",
                  "# Total length (>= 0 bp)      253532312",
                  "# Total length (>= 1000 bp)   253532312",
                  "# Total length (>= 5000 bp)   253532312",
                  "# Total length (>= 10000 bp)  253532312",
                  "# Total length (>= 25000 bp)  253532312",
                  "# Total length (>= 50000 bp)  253342675",
                  "# # contigs                   49",
                  "# Largest contig              38206310",
                  "# Total length                253532312",
                  "# GC (%)                      39.38",
                  "# N50                         33891589",
                  "# N75                         27307903",
                  "# L50                         4",
                  "# L75                         6",
                  "# # N's per 100 kbp           0.12",
                  "#",
                  "# Annotation",
                  "#",
                  "# Annotation generated by Milos Duchoslav (Group of Filip Kolar, ",
                  "# Department of Botany, Faculty of Science, Charles University, Prague, Czechia).",
                  "# Email: duchmil[at]gmail.com",
                  "# ",
                  "# Protein coding genes were predicted by",
                  "# BRAKER version 3.0.8 based on RNA-seq data from Noccaea praecox ",
                  "# and OrthoDB proteins from the whole Viridiplantae.",
                  "# ",
                  "# To include non-coding RNA genes and similar features,",
                  "# transcripts assembled from RNA-seq data using StringTie v2.2.2",
                  "# were filtered using bedtools v2.30.0 to keep only those that",
                  "# do not have any overlap with protein-coding gene annotations.",
                  "# They were included in annotation as 'ncRNA_gene' and 'ncRNA'.",
                  "# However, they are simply regions that are transcribed and ",
                  "# probably are not protein-coding genes.",
                  "# ",
                  "# GTF converted to GFF using AGAT v1.4.0.",
                  "# Feature IDs changed using custom R script.",
                  "# ",
                  "# Message for Terka from Milos: If you find this, I will buy you an icecream.",
                  "# ",
                  "# Annotation statistics",
                  "# ",
                  "# Type (3rd column)  Number  Size total (kb)  Size mean (bp)  % of the genome",
                  "# cds                162102         39991.15          246.70            15.77",
                  "# exon               204900         51933.35          253.46            20.48",
                  "# gene                30370         58044.34         1911.24            22.89",
                  "# intron             128180         28124.76          219.42            11.09",
                  "# ncrna               17432         24532.59         1407.33             9.68",
                  "# ncrna_gene          13747         16618.45         1208.88             6.55",
                  "# start_codon         33914           101.72            3.00             0.04",
                  "# stop_codon          33914           101.72            3.00             0.04",
                  "# transcript          33922         68115.92         2008.02            26.87",
                  "# Total              658481        287564.00          436.71           113.42",
                  "# "
)

# gff.header.2 <- gff.header
```
### Writing GFF file
```{r eval=FALSE}
# write header to file
write.table(x = gff.header.3, 
            file = "annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff", 
            sep = "\t",
            row.names = F, col.names = F, quote = F)
# append the gff itself
write.table(x = gff.4, 
            file = "annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff", 
            sep = "\t",
            row.names = F, col.names = F, quote = F, append = T)
```

## Statistics of annotation and extraction of protein and coding sequences using AGAT
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/stat_annotation

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# basic statistics
agat_sq_stat_basic.pl -i ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -g ../genome_assembly/Noccaea_praecox_CUNI_V1_2024_10_masked.fa > stat_basic_Noccaea_praecox_CUNI_V1_annotation_v1.1.gff.txt

# detailed statistics
agat_sp_statistics.pl -i ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -g ../genome_assembly/Noccaea_praecox_CUNI_V1_2024_10_masked.fa > stat_detailed_Noccaea_praecox_CUNI_V1_annotation_v1.1.gff.txt

# view the basic statistics
tail -n +11 stat_basic_Noccaea_praecox_CUNI_V1_annotation_v1.1.gff.txt | column -s $'\t' -t -R 2,3,4,5
```

Type (3rd column)  Number  Size total (kb)  Size mean (bp)  % of the genome
cds                162102         39991.15          246.70            15.77
exon               204900         51933.35          253.46            20.48
gene                30370         58044.34         1911.24            22.89
intron             128180         28124.76          219.42            11.09
ncrna               17432         24532.59         1407.33             9.68
ncrna_gene          13747         16618.45         1208.88             6.55
start_codon         33914           101.72            3.00             0.04
stop_codon          33914           101.72            3.00             0.04
transcript          33922         68115.92         2008.02            26.87
Total              658481        287564.00          436.71           113.42

Previous version without removing genes with intrnal stop codons:

Type (3rd column) Number Size total (kb) Size mean (bp) % of the genome
cds               162105        40010.28         246.82           15.78
exon              204900        51950.28         253.54           20.49
gene               30373        58063.47        1911.68           22.90
intron            128180        28124.76         219.42           11.09
ncrna              17430        24524.40        1407.02            9.67
ncrna_gene         13745        16610.27        1208.46            6.55
start_codon        33917          101.73           3.00            0.04
stop_codon         33916          101.72           3.00            0.04
transcript         33925        68135.05        2008.40           26.87
Total             658491       287621.97         436.79          113.45


## Extraction of proteins and CDS

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# Protein sequences
agat_sp_extract_sequences.pl -g Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -f ../genome_assembly/Noccaea_praecox_CUNI_V1_2024_10_masked.fa -p -o Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta
# CDS
agat_sp_extract_sequences.pl -g Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -f ../genome_assembly/Noccaea_praecox_CUNI_V1_2024_10_masked.fa -t cds -o Noccaea_praecox_CUNI_V1_annotation_v1.1_cds.fasta

# counting the number of sequences
grep -c ">" Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta # 33922
grep -c ">" Noccaea_praecox_CUNI_V1_annotation_v1.1_cds.fasta # 33922


# converting from folded fasta to unfolded fasta for better counting and checking for internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta | grep \*[[:alpha:]] | wc -l
# 0

awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta | grep -B1 '\*[[:alpha:]]'
```


# Final files

Move the final files.

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/annot_processing

# compress the final files by gzip
gzip --keep Noccaea_praecox_CUNI_V1_annotation_v1.1.gff Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta Noccaea_praecox_CUNI_V1_annotation_v1.1_cds.fasta

# directory for final files
mkdir -p /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/final_files

# move the final files
mv -vt /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/final_files Noccaea_praecox_CUNI_V1_annotation_v1.1.gff.gz Noccaea_praecox_CUNI_V1_annotation_v1.1_proteins.fasta.gz Noccaea_praecox_CUNI_V1_annotation_v1.1_cds.fasta.gz


# compress genome assembly and add it to final files
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/genome_assembly
genome_assembly="Noccaea_praecox_CUNI_V1_2024_10_masked.fa"

gzip --keep $genome_assembly
mv -vt /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/final_files $genome_assembly.gz
```


# Reliability of the predicted genes

*This part of the script was added later according to script fo Odontarrhena.*

This is one of the quality checks. I will produce a table that will show how reliable the predicted genes are (if they have support in RNAseq data or aligned proteins from other species).

## Intersect between gene models and aligned proteins
bedtools intersect
https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12
mkdir -p intersects
cd intersects

module load bedtools2/2.30.0-gcc-10.2.1-5acjqve

ls ../protein_seqs_input/2_aligned/

# Intersects with proteins from single species
bedtools intersect -a ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -b ../protein_seqs_input/2_aligned/A.thaliana.pep.gff -u -f 0.9 -r > braker_annotation_x_A.thaliana.pep.gff_intersect.tab

bedtools intersect -a ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -b ../protein_seqs_input/2_aligned/A.lyrata.pep.gff -u -f 0.9 -r > braker_annotation_x_A.lyrata.pep.gff_intersect.tab

bedtools intersect -a ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -b ../protein_seqs_input/2_aligned/B.rapa.pep.gff -u -f 0.9 -r > braker_annotation_x_B.rapa.pep.gff_intersect.tab

# Intersect with all proteins together
bedtools intersect -a ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -b ../protein_seqs_input/2_aligned/*  -u -f 0.9 -r > braker_annotation_x_all.pep.gff_intersect.tab

```
This command finds the intersects between Braker output (`-a`) and at least one of the aligned proteins (files in `-b`).
It will report the genes in `-a` only once (option `-u`). The overlap should be at least 90 % (`-f 0.9`) for both `-a` and `-b` (option `-r` as reciprocal). 


## Intersect between gene models and assembled transcripts
Again bedtools intersect.
This time we do not use the `-r` option - the overlap should be at least 90 % of Braker output, but not necesarilly of the Stringtie output. It is because the Stringtie tries to predict whole transcripts including UTRs.

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/intersects

module load bedtools2/2.30.0-gcc-10.2.1-5acjqve

ls ../rnaseq/4_assembled_transcripts/

# Intersects with Stringtie assembled transcripts
bedtools intersect -a ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff -b ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf -u -f 0.9 > braker_annotation_x_Assembled_transcripts.gtf_intersect.tab

# Number of genes predicted by Braker
grep -P -c "\tgene\t" ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff # 30370
# Number of transcripts assembled from RNAseq
grep -P -c "\ttranscript\t" ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf # 57671
# Number of genes assembled from RNAseq
# (Gene features are not annotated separately by StringTie, but there is a field gene_id for transcripts which can be used.)
grep -P "\ttranscript\t" ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf | sed -E 's/.*\tgene_id//' | sed -E 's/; transcript_id.*//' | sort -u | wc -l # 39004
# Intersect of genes predicted by Braker and transcripts assembled from RNAseq
grep -P -c "\tgene\t" braker_annotation_x_Assembled_transcripts.gtf_intersect.tab # 21454

```
**Note**
There is a problem that some of the assembled transcripts have long introns. If the whole gene predicted by Braker falls within intron of assembled transcript, it is still reported as supported, even if no reads map to this region. I don't have any easy solution how to solve this for now.

### Checking the outputs

Here I look at the number of genes that are reported to have intersect with some aligned protein. There is a possibility that only some shorter transcript (splicing variant) of the particular gene have overlap big enough to be reported. Later I am putting into the reliability table also these transcripts and their particular genes, so the numbers might be slightly higher.

```{sh}
grep -P -c "\tgene\t" ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff # 30370
# grep -P -c "\tmRNA\t" ../protein_seqs_input/2_aligned/A.thaliana.pep.gff # 47853
# grep -P -c "\tgene\t" braker_annotation_x_A.thaliana.pep.gff_intersect.tab # 16967

for FILE in braker_annotation_x_*.tab
do
COUNT=$(grep -P -c "\tgene\t" $FILE)
echo "$FILE $COUNT"
done

```


## Generating table of reliability of genes

Table will be generated from intersects of genes predicted by Braker and aligned RNAseq data and proteins from other Brassicaceae species. It will show which genes are supported by additional data and which not.

Using only protein coding genes for now. Also other genes could be used in the future.

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/intersects

# checks
# grep -P "\tgene\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9 | sed 's/ID=//' | sort | head -n 20
# this will use genes belonging to all transcripts that were supported
grep -P "\ttranscript\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9 | sed 's/^.*Parent=//' | sort --unique | head -n 20
# Use also nc_RNA genes? Not now...
grep -P "\t(transcript|ncRNA)\t" braker_annotation_x_all.pep.gff_intersect.tab | cut -f 9 | sed 's/^.*Parent=//' | sed 's/;.*$//' | less

## Get the lists of genes from intersects
# This will extract genes belonging to all transcripts that were supported.
# It might be different from the case when I take just the "gene" features from GFF - there could be supported just one transcript and not the entire gene.
for FILE in braker_annotation_x_*_intersect.tab
do
NEW_FILE=$(echo $FILE | sed 's/.tab$/_genes.txt/')
# Extract transcripts and get the gene IDs from them.
grep -P "\ttranscript\t" $FILE | cut -f 9 | sed 's/^.*Parent=//' | sort --unique > $NEW_FILE
# number of genes extracted
echo $(wc -l $NEW_FILE)
done

## Get the list of genes from the annotation
# Just protein coding genes.
grep -P "\tgene\t" ../annot_processing/Noccaea_praecox_CUNI_V1_annotation_v1.1.gff | cut -f 9 | sed 's/ID=//' | sed 's/\r$//' | sort > protein_coding_genes.txt
wc -l protein_coding_genes.txt


## AWK script generating the table
# I will use also the list of all protein coding genes (to have a full list of genes) and then I will remove the respective column, where will be only ones and no zeros.
awk 'FNR==1{
    f++
    fname = FILENAME
    gsub(/^braker_annotation_x_/, "", fname)   # remove prefix
    gsub(/\.g[tf]f_intersect_genes\.txt$/, "", fname) # remove suffix
    files[f] = fname
}
{
    a[$1][f] = 1
}
END{
    # header
    printf "Gene"
    for(i=1;i<=f;i++) printf "\t%s", files[i]
    print ""

    # collect all gene names
    for(g in a) genes[++n] = g

    # sort gene names
    n = asort(genes)

    # print rows
    for(j=1;j<=n;j++){
        g = genes[j]
        printf "%s", g
        for(i=1;i<=f;i++) printf "\t%d", (a[g][i]?1:0)
        print ""
    }
}' protein_coding_genes.txt braker_annotation_x_Assembled_transcripts.gtf_intersect_genes.txt braker_annotation_x_A.lyrata.pep.gff_intersect_genes.txt braker_annotation_x_A.thaliana.pep.gff_intersect_genes.txt braker_annotation_x_B.rapa.pep.gff_intersect_genes.txt | 
     # remove the column with all genes ("protein_coding_genes.txt")
     cut -f2 --complement > Noccaea_praecox_CUNI_V1_annotation_v1.1_protein_coding_genes_support.tsv

# check - this should be number of gene features in final gff plus one for header
wc -l Noccaea_praecox_CUNI_V1_annotation_v1.1_protein_coding_genes_support.tsv

# Copying the reliability table to final files
cp -v Noccaea_praecox_CUNI_V1_annotation_v1.1_protein_coding_genes_support.tsv /storage/brno12-cerit/home/duchmil/annotations/Noccaea_praecox_2024_12/final_files/

```




To do:
- zkontrolovat anotaci v IGV (porovnat s GTF)








# Old parts of script





Udělat
- predict lncRNAs?
  - nebo "expressed features"?
- přejmenovat
- převést na gff3
- kvalita predikovaných genů
  - expressed
  - protein support
- znovu RNAseq pro další anotaci?
- Orthofinder

- prozkoumat PsbO - jen 1x?




To do:
Možná upravit parents pro transcript ještě v gtf? A změnit id v GTF? Odstranit mRNA, které vypadají redundantně?

Links for GTF and GFF specs: https://www.ncbi.nlm.nih.gov/genbank/genomes_gff/

1. Zjistit, jestli je mRNA redundantní s transkriptem. Pokud ano, odstranit.
2. Druhý sloupec - přidat BRAKER
3. DOplnit hlavičku.
4. Vyměnit ID genů a dalších


## Changing IDs in R


```{r}
setwd("D:/!ecolgen/annotations/Alyssum/Noccaea_praecox_2024_12")

# read the gff file
gff.1 <- read.table(file = "annot_processing/alyssum_01_braker.gff", header = F, sep = "\t", comment.char = "#" 
                     #, nrows = 1500
                    )
summary(gff.1)
head(gff.1)
gff.1[1:50, ]
```

What feature types are there?

```{r}
# Types of features
levels(as.factor(gff.1$V3))
table(as.factor(gff.1$V3))

# scaffold names
levels(as.factor(gff.1$V1))
```

```{r}
# mRNA is there only for genes predicted by GeneMark.hmm3
gff.1[grepl(pattern = "mRNA|transcript", x = gff.1$V3), ][1:40, ]
# It seems that mRNA is redundant with transcript
gff.1[grepl(pattern = "mRNA|transcript", x = gff.1$V3) & grepl(pattern = "GeneMark.hmm3", x = gff.1$V2), ][1:40, ]
# It doesn't have any childs features.
gff.1[grepl(pattern = "GeneMark.hmm3", x = gff.1$V2), ][1:40, ]

# I will remove mRNA features.
gff.2 <- gff.1[gff.1$V3 != "mRNA", ]
dim(gff.1)
dim(gff.2)
```


Changing IDs:
```{r}
gff.2[1:40, ]
gff.2[grepl(pattern = "gene", x = gff.2$V3), ][1:40, ]

# old gene names
old.genes <- sub(pattern = "ID=", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V9"])
scaff.genes <- gsub(pattern = "ptg000|[lc]$", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V1"])
levels(as.factor(scaff.genes))

# making new gene names
vowel <- c("a", "e", "i", "o", "u")
cons <- letters[!letters %in% c(vowel, "y")]
# making syllables (consonant + vowel)
syllable <- paste0(rep(x = cons, each = length(vowel)), rep(x = vowel, times = length(cons)))
# When "y" is ommited, there are exactly 100 various syllables.
length(syllable)
# How many words of different length do we get?
length(syllable)^(1:10)

# 4 letter words
syllables2 <- paste0(rep(x = syllable, each = length(syllable)), rep(x = syllable, times = length(syllable)))
# 6 letter words
syllables3 <- paste0(rep(x = syllable, each = length(syllables2)), rep(x = syllables2, times = length(syllable)))
length(syllables3)

# New gene names with species code and readable ID
new.genes <- paste0("AM", scaff.genes, syllables3[1:length(old.genes)])

# safe number of genes for later use
(protein.coding.genes <- length(old.genes)) # 32073

genes <- cbind.data.frame(old.genes, new.genes, scaff.genes)
tail(genes)

# gff.3 <- gff.2[1:1000, ]
# for(i in 1:nrow(genes)) {
#   system.time(descr1 <- gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"])
#   # descr2 <- gsub(pattern = paste0("=", genes$old.genes[i], ";"), 
#   #                replacement = paste0("=", genes$new.genes[i], ";"), 
#   #                x = descr1)
#   # descr3 <- gsub(pattern = paste0("=", genes$old.genes[i], "\\.t"), 
#   #                replacement = paste0("=", genes$new.genes[i], ".t"), 
#   #                x = descr2)
#   # descr4 <- gsub(pattern = paste0("=", genes$old.genes[i], "$"), 
#   #                replacement = paste0("=", genes$new.genes[i], "."), 
#   #                x = descr3)
#   # descr5 <- descr4
#   # exons <- descr5[grep(pattern = "ID=agat-exon-[[:digit:]]+;", x = descr4)]
#   # transcripts <- gsub(pattern = ".*transcript_id=", replacement = "", x = exons)
#   # exons1 <- mapply(sub, pattern = "ID=agat-exon-[[:digit:]]+;", replacement = paste0("ID=exon-", transcripts, "-", 1:length(exons), ";"), x = exons, USE.NAMES = F)
# 
# # print(Sys.time())
#   
#   
#   patterns <- c(paste0("=", genes$old.genes[i], ";"),
#                 paste0("=", genes$old.genes[i], "\\.t"),
#                 paste0("=", genes$old.genes[i], "$")#,
#                 #"ID=agat-exon-[[:digit:]]+;"
#                 )
#   replacements <- c(paste0("=", genes$new.genes[i], ";"),
#                         paste0("=", genes$new.genes[i], ".t"),
#                         paste0("=", genes$new.genes[i])#,
#                     #paste0("ID=exon-", genes$new.genes[i], "-#;")
#                     )
#   descr2 <- descr1
#   system.time(for(j in 1:length(patterns)) {
#     descr2 <- gsub(pattern = patterns[j], 
#                  replacement = replacements[j], 
#                  x = descr2)
#   })
#   
#   system.time(for(feature in c("exon", "intron", "cds", "start_codon", "stop_codon")) {
#     extr.feature <- descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)]
#     if(length(extr.feature) > 0) {
#       transcripts <- gsub(pattern = ".*transcript_id=", replacement = "", x = extr.feature)
#       mod.feature <- mapply(sub, 
#                             pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), 
#                             replacement = paste0("ID=", feature, "-", transcripts, "-", 1:length(extr.feature), ";"), 
#                             x = extr.feature, USE.NAMES = F)
#       descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)] <- mod.feature
#     }
#   })
#   
#   system.time(gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"] <- descr2)
#   if(i %% 10 == 0) print(paste(i, "out of", nrow(genes), "done"))
#   # i=i+1
# }

# Row numbers where data for one gene begin and end are needed (see the loop below)
# GFF needs to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene).
genes$rows <- grep(pattern = "gene", x = gff.2$V3)
genes$end.rows <- NA
genes$end.rows[1:(nrow(genes)-1)] <- genes$rows[2:nrow(genes)]-1
genes$end.rows[nrow(genes)] <- nrow(gff.2)
tail(genes)

# New gff
gff.3 <- gff.2

## Loop to make new feature ids in GFF

# Gene names will be changed to new ones.
# Transcript names will be in the form gene_name.t1.
# Other features ("exon", "intron", "cds", "start_codon", "stop_codon") will have IDs in form "exon-AM_transcript_id-1", where the last number will count exons in that particular transcript.

# Warning:
# This loops expect the GFF to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene, the same should be valid for transcripts of one gene). First, I tried to make it more universal, but it was always searching for the rows for one gene using grep, which was slow like a hell.
for(i in 1:nrow(genes)) {
  # Extract rows for one gene and its subfeatures.
  descr1 <- gff.2[genes$rows[i]:genes$end.rows[i], "V9"]
  
  # grep version (slow)
  # descr1 <- gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"]
  
  # Patterns defining how to find old gene name within different context.
  patterns <- c(paste0("=", genes$old.genes[i], ";"),
                paste0("=", genes$old.genes[i], "\\.t"),
                paste0("=", genes$old.genes[i], "$")#,
                #"ID=agat-exon-[[:digit:]]+;"
                )
  
  # Strings defining what to exchange the previous patterns for
  replacements <- c(paste0("=", genes$new.genes[i], ";"),
                        paste0("=", genes$new.genes[i], ".t"),
                        paste0("=", genes$new.genes[i])#,
                    #paste0("ID=exon-", genes$new.genes[i], "-#;")
                    )
  
  descr2 <- descr1
  
  # Loop exchanging patterns for replacements
  for(j in 1:length(patterns)) {
    descr2 <- gsub(pattern = patterns[j], 
                 replacement = replacements[j], 
                 x = descr2)
  }
  
  # Loop to change IDs of features other than genes or transcripts
  for(feature in c("exon", "intron", "cds", "start_codon", "stop_codon")) {
    # Extract rows for one feature
    extr.feature <- descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)]
    # For some genes, there are no introns and it would make mess if we try to exchange something
    if(length(extr.feature) > 0) {
      # Transcript IDs
      transcripts <- gsub(pattern = ".*transcript_id=", replacement = "", x = extr.feature)
      # Sequence of numbers for features within transcript and gene (1 to n for every transcript)
      feat.numbers <- unlist(mapply(seq, from = 1, to = table(transcripts)))
      # Modify the feature IDs
      mod.feature <- mapply(sub, 
                            pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), 
                            replacement = paste0("ID=", feature, "-", transcripts, "-", feat.numbers, ";"), 
                            x = extr.feature, USE.NAMES = F)
      # Replace rows with modified ones
      descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)] <- mod.feature
    }
  }
  
  # Replace info in column 9 of GFF for the modified one
  gff.3[genes$rows[i]:genes$end.rows[i], "V9"] <- descr2
  # grep version (slow)
  # gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"] <- descr2
  
  # For every 100 genes, print the counting
  if(i %% 100 == 0) print(paste(i, "genes out of", nrow(genes), "done"))
  # i=i+1
}

tail(gff.3, n = 40)
# tail(gff.3, n = 100)
# 
# gff.3[grep(pattern = "=g365(;|\\.t|$)", x = gff.2$V9), ] 
#   
# i=1
# i=2
# i=4
# i=50
# i=65
# feature = "exon"
# feature = "intron"
# gff.2[grepl(pattern = "exon", x = gff.2$V3), ][1:40, ]
# tail(gff.2)
# gff.4[grepl(pattern = "\\.t2", x = gff.2$V9), ][1:40, ]
# gff.2[grep(pattern = "=g65(;|\\.t|$)", x = gff.2$V9), 2:9]
# gff.2[grepl(pattern = "Parent=g[^8]*g.*", x = gff.2$V9), ]
# 
# gff.4 <- gff.3

## Change of column 2
gff.4 <- gff.3
levels(as.factor(gff.3$V2))
gff.4$V2 <- paste0("BRAKER-", gff.3$V2)
levels(as.factor(gff.4$V2))


# read the header of gff file
gff.raw <- readLines(con = "annot_processing/alyssum_01_braker.gff" 
                     , n = 1500
                    )
gff.header <- gff.raw[grep(pattern = "^#", x = gff.raw)]

# add my lines to the header
## Note: This header will not be used later, I will exchange it for better one whil merging this annotation with annotation of unknown expressed features.
gff.header.2 <- rbind(gff.header,
                      "# Alyssum montanum genome annotation",
                      "# 2024-07-31",
                      "#",
                      "# Genome assembly",
                      "#",
                      "# File alyssum_v2_Mahnaz_2024_masked.fa",
                      "# # contigs (>= 0 bp)         168",
                      "# # contigs (>= 1000 bp)      168",
                      "# # contigs (>= 5000 bp)      168",
                      "# # contigs (>= 10000 bp)     168",
                      "# # contigs (>= 25000 bp)     163",
                      "# # contigs (>= 50000 bp)     108",
                      "# Total length (>= 0 bp)      683338063",
                      "# Total length (>= 1000 bp)   683338063",
                      "# Total length (>= 5000 bp)   683338063",
                      "# Total length (>= 10000 bp)  683338063",
                      "# Total length (>= 25000 bp)  683223685",
                      "# Total length (>= 50000 bp)  681172935",
                      "# # contigs                   168",
                      "# Largest contig              33309422",
                      "# Total length                683338063",
                      "# GC (%)                      38.45",
                      "# N50                         12254332",
                      "# N75                         7380926",
                      "# L50                         17",
                      "# L75                         35",
                      "# # N's per 100 kbp           0.00",
                      "#",
                      "# Annotation",
                      "#",
                      "# Annotation generated by Milos Duchoslav (Group of Filip Kolar, ",
                      "# Department of Botany, Faculty of Science, Charles University, Prague, Czechia).",
                      "# Email: duchmil[at]gmail.com",
                      "# Prediction by BRAKER version 3.0.8 based on RNA-seq data from Alyssum montanum ",
                      "# and OrthoDB proteins from the whole Viridiplantae.",
                      "# GTF converted to GFF using AGAT v1.4.0.",
                      "# Feature IDs changed using custom R script.")


```

```{r eval=FALSE}
# write header to file
write.table(x = gff.header.2, file = "annot_processing/alyssum_01_changed_IDs.gff", sep = "\t",
            row.names = F, col.names = F, quote = F)
# append the gff itself
write.table(x = gff.4, file = "annot_processing/alyssum_01_changed_IDs.gff", sep = "\t",
            row.names = F, col.names = F, quote = F, append = T)
```


## Statistics of annotation and extraction of protein and coding sequences using AGAT
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/stat_annotation

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# basic statistics
agat_sq_stat_basic.pl -i ../annot_processing/alyssum_01_changed_IDs.gff -g ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa > stat_basic_alyssum_01_changed_IDs.gff.txt

# detailed statistics
agat_sp_statistics.pl -i ../annot_processing/alyssum_01_changed_IDs.gff -g ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa > stat_detailed_alyssum_01_changed_IDs.gff.txt
```
Basic statistics:

Type (3rd column)       Number  Size total (kb) Size mean (bp)  % of the genome /!\Results are rounding to two decimal places
cds     173921  42686.71        245.44  6.25
exon    173921  42686.71        245.44  6.25
gene    32073   62652.25        1953.43 9.17
intron  138011  29917.95        216.78  4.38
start_codon     35902   107.68  3.00    0.02
stop_codon      35902   107.69  3.00    0.02
transcript      35910   72604.66        2021.85 10.62
Total   625640  250763.65       400.81  36.70

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/annot_processing

# Protein sequences
agat_sp_extract_sequences.pl -g alyssum_01_changed_IDs.gff -f ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa -p -o alyssum_01_changed_IDs_proteins.fasta
# CDS
agat_sp_extract_sequences.pl -g alyssum_01_changed_IDs.gff -f ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa -t cds -o alyssum_01_changed_IDs_cds.fasta

# counting the number of sequences
grep -c ">" alyssum_01_changed_IDs_proteins.fasta
grep -c ">" alyssum_01_changed_IDs_cds.fasta


# converting from folded fasta to unfolded fasta for better counting and checking for internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < alyssum_01_changed_IDs_proteins.fasta | grep \*[[:alpha:]] | wc -l
# 0
```


## Changing IDs of unknown expressed features in R


```{r}
setwd("D:/!ecolgen/annotations/Alyssum/Alyssum_assembly_from_Mahnaz_2024_05")

# read the gff file
gff.1 <- read.table(file = "annot_processing/Assembled_transcripts_with_no_annotation_overlap_clean.gff", header = F, sep = "\t", comment.char = "#" 
                     #, nrows = 1500
                    )
summary(gff.1)
head(gff.1)
gff.1[1:50, ]
```

### What feature types are there?

```{r}
# Types of features
levels(as.factor(gff.1$V3))
table(as.factor(gff.1$V3))

# scaffold names
levels(as.factor(gff.1$V1))
```

### Changing IDs
```{r}
table(as.factor(gff.1$V2))
table(as.factor(gff.1$V2), as.factor(gff.1$V3))


# Genes added by AGAT to assembled transcript - change col 2 to "StringTie"
gff.2[gff.2[, 2] == "AGAT", 2] <- "StringTie"

gff.2[1:40, ]

# For features "gene", remove cov, fPKM, tPM and transcript_id, because AGAT copied it just from the first transcript
gff.2[grepl(pattern = "gene", x = gff.2$V3), 9][1:40]
# For some genes, there is also "exon_number", which I will also remove.
gff.2[grepl(pattern = "STRG.378", x = gff.2$V9), ][1:40, ]
gff.1[grepl(pattern = "STRG.1415", x = gff.2$V9), ][1:40, ]

gene.col9.1 <- gff.2[grepl(pattern = "gene", x = gff.2$V3), 9]
gene.col9.2 <- gsub(pattern = ";*cov=[0-9.]+;*", replacement = ";", x = gene.col9.1)
gene.col9.3 <- gsub(pattern = ";*fPKM=[0-9.]+;*", replacement = ";", x = gene.col9.2)
gene.col9.4 <- gsub(pattern = ";*tPM=[0-9.]+;*", replacement = ";", x = gene.col9.3)
gene.col9.5 <- gsub(pattern = ";*exon_number=[0-9.]+;*", replacement = ";", x = gene.col9.4)
gene.col9.6 <- gsub(pattern = ";*transcript_id=STRG[0-9.]+;*", replacement = "", x = gene.col9.5)
gff.2[grepl(pattern = "gene", x = gff.2$V3), 9] <- gene.col9.6

gff.2[1:40, ]

# old gene names
old.genes <- gsub(pattern = "ID=|;gene_id.*$", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V9"])
scaff.genes <- gsub(pattern = "ptg000|[lc]$", replacement = "", x = gff.2[grepl(pattern = "gene", x = gff.2$V3), "V1"])
levels(as.factor(scaff.genes))

# making new gene names
vowel <- c("a", "e", "i", "o", "u")
cons <- letters[!letters %in% c(vowel, "y")]
# making syllables (consonant + vowel)
syllable <- paste0(rep(x = cons, each = length(vowel)), rep(x = vowel, times = length(cons)))
# When "y" is ommited, there are exactly 100 various syllables.
length(syllable)
# How many words of different length do we get?
length(syllable)^(1:10)

# 4 letter words
syllables2 <- paste0(rep(x = syllable, each = length(syllable)), rep(x = syllable, times = length(syllable)))
# 6 letter words
syllables3 <- paste0(rep(x = syllable, each = length(syllables2)), rep(x = syllables2, times = length(syllable)))
length(syllables3)

# New gene names with species code and readable ID
# use protein.coding.genes saved when assigning new IDs to protein coding genes
new.genes <- paste0("AM", scaff.genes, syllables3[(protein.coding.genes + 1):(protein.coding.genes + length(old.genes))])

genes <- cbind.data.frame(old.genes, new.genes, scaff.genes)
head(genes)
tail(genes)


# Row numbers where data for one gene begin and end are needed (see the loop below)
# GFF needs to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene).
genes$rows <- grep(pattern = "gene", x = gff.2$V3)
genes$end.rows <- NA
genes$end.rows[1:(nrow(genes)-1)] <- genes$rows[2:nrow(genes)]-1
genes$end.rows[nrow(genes)] <- nrow(gff.2)
tail(genes)

# New gff
gff.3 <- gff.2

## Loop to make new feature ids in GFF

# Gene names will be changed to new ones.
# Transcript names will be in the form gene_name.t1.
# Other features ("exon", "intron", "cds", "start_codon", "stop_codon") will have IDs in form "exon-AM_transcript_id-1", where the last number will count exons in that particular transcript.

# Warning:
# This loops expect the GFF to be ordered (rows for one gene and its subfeatures should't be interspersed with data for other gene, the same should be valid for transcripts of one gene). First, I tried to make it more universal, but it was always searching for the rows for one gene using grep, which was slow like a hell.
for(i in 1:nrow(genes)) {
  # Extract rows for one gene and its subfeatures.
  descr1 <- gff.2[genes$rows[i]:genes$end.rows[i], "V9"]
  
  # grep version (slow)
  # descr1 <- gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"]
  
  # Patterns defining how to find old gene name within different context.
  patterns <- c(paste0("=", genes$old.genes[i], ";"),
                paste0("=", genes$old.genes[i], "\\."),
                paste0("=", genes$old.genes[i], "$")#,
                #"ID=agat-exon-[[:digit:]]+;"
                )
  
  # Strings defining what to exchange the previous patterns for
  replacements <- c(paste0("=", genes$new.genes[i], ";"),
                        paste0("=", genes$new.genes[i], ".t"),
                        paste0("=", genes$new.genes[i])#,
                    #paste0("ID=exon-", genes$new.genes[i], "-#;")
                    )
  
  descr2 <- descr1
  
  # Loop exchanging patterns for replacements
  for(j in 1:length(patterns)) {
    descr2 <- gsub(pattern = patterns[j], 
                 replacement = replacements[j], 
                 x = descr2)
  }
  
  # Loop to change IDs of features other than genes or transcripts
  for(feature in c("exon", "intron", "cds", "start_codon", "stop_codon")) {
    # Extract rows for one feature
    extr.feature <- descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)]
    # For some genes, there are no introns and it would make mess if we try to exchange something
    if(length(extr.feature) > 0) {
      # Transcript IDs
      transcripts <- gsub(pattern = ".*transcript_id=", replacement = "", x = extr.feature)
      # Sequence of numbers for features within transcript and gene (1 to n for every transcript)
      feat.numbers <- unlist(mapply(seq, from = 1, to = table(transcripts)))
      # Modify the feature IDs
      mod.feature <- mapply(sub, 
                            pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), 
                            replacement = paste0("ID=", feature, "-", transcripts, "-", feat.numbers, ";"), 
                            x = extr.feature, USE.NAMES = F)
      # Replace rows with modified ones
      descr2[grep(pattern = paste0("ID=agat-", feature, "-[[:digit:]]+;"), x = descr2)] <- mod.feature
    }
  }
  
  # Replace info in column 9 of GFF for the modified one
  gff.3[genes$rows[i]:genes$end.rows[i], "V9"] <- descr2
  # grep version (slow)
  # gff.3[grep(pattern = paste0("=", genes$old.genes[i], "(;|\\.t|$)"), x = gff.2$V9), "V9"] <- descr2
  
  # For every 100 genes, print the counting
  if(i %% 100 == 0) print(paste(i, "genes out of", nrow(genes), "done"))
  # i=i+1
}

tail(gff.3, n = 40)
# tail(gff.3, n = 100)
# 
# gff.3[grep(pattern = "=g365(;|\\.t|$)", x = gff.2$V9), ] 
#   
# i=1
# i=2


gff.4 <- gff.3

# Changing feature names
gff.4$V3[gff.4$V3 == "gene"] <- "ncRNA_gene"
gff.4$V3[gff.4$V3 == "transcript"] <- "ncRNA"

levels(as.factor(gff.4$V3))


# read the header of gff file
gff.raw <- readLines(con = "annot_processing/Assembled_transcripts_with_no_annotation_overlap_clean.gff" 
                     , n = 1500
                    )
gff.header <- gff.raw[grep(pattern = "^#", x = gff.raw)]

# add my lines to the header
gff.header.2 <- rbind(gff.header,
                      "# Alyssum gmelinii (A. montanum group) genome annotation",
                      "# 2024-09-06",
                      "#",
                      "# Genome assembly",
                      "#",
                      "# File alyssum_v2_Mahnaz_2024_masked.fa",
                      "# # contigs (>= 0 bp)         168",
                      "# # contigs (>= 1000 bp)      168",
                      "# # contigs (>= 5000 bp)      168",
                      "# # contigs (>= 10000 bp)     168",
                      "# # contigs (>= 25000 bp)     163",
                      "# # contigs (>= 50000 bp)     108",
                      "# Total length (>= 0 bp)      683338063",
                      "# Total length (>= 1000 bp)   683338063",
                      "# Total length (>= 5000 bp)   683338063",
                      "# Total length (>= 10000 bp)  683338063",
                      "# Total length (>= 25000 bp)  683223685",
                      "# Total length (>= 50000 bp)  681172935",
                      "# # contigs                   168",
                      "# Largest contig              33309422",
                      "# Total length                683338063",
                      "# GC (%)                      38.45",
                      "# N50                         12254332",
                      "# N75                         7380926",
                      "# L50                         17",
                      "# L75                         35",
                      "# # N's per 100 kbp           0.00",
                      "#",
                      "# Annotation",
                      "#",
                      "# Annotation generated by Milos Duchoslav (Group of Filip Kolar, ",
                      "# Department of Botany, Faculty of Science, Charles University, Prague, Czechia).",
                      "# Email: duchmil[at]gmail.com",
                      "# ",
                      "# Protein coding genes were predicted by",
                      "# BRAKER version 3.0.8 based on RNA-seq data from Alyssum montanum ",
                      "# and OrthoDB proteins from the whole Viridiplantae.",
                      "# ",
                      "# To include non-coding RNA genes and similar features,",
                      "# transcripts assembled from RNA-seq data using StringTie v2.2.2",
                      "# were filtered using bedtools v2.30.0 to keep only those that",
                      "# do not have any overlap with protein-coding gene annotations.",
                      "# They were included in annotation as 'ncRNA_gene' and 'ncRNA'.",
                      "# However, they are simply regions that are transcribed and ",
                      "# probably are not protein-coding genes.",
                      "# ",
                      "# GTF converted to GFF using AGAT v1.4.0.",
                      "# Feature IDs changed using custom R script.",
                      "# ",
                      "# Annotation statistics",
                      "# ",
                      "# Type (3rd column) Number Size total (kb) Size mean (bp) % of the genome",
                      "# cds               173921 42686.71        245.44         6.25",
                      "# exon              250209 63637.83        254.34         9.31",
                      "# gene              32073  62652.25        1953.43        9.17",
                      "# intron            138011 29917.95        216.78         4.38",
                      "# ncrna             30166  53606.29        1777.04        7.84",
                      "# ncrna_gene        23116  37393.54        1617.65        5.47",
                      "# start_codon       35902  107.68          3.00           0.02",
                      "# stop_codon        35902  107.69          3.00           0.02",
                      "# transcript        35910  72604.66        2021.85        10.62",
                      "# Total             755210 362714.59       480.28         53.08",
                      "# "
)


```

### Writing GFF file
```{r eval=FALSE}
# write header to file
write.table(x = gff.header.2, 
            file = "annot_processing/Assembled_transcripts_with_no_annotation_overlap_clean_changed_IDs.gff", 
            sep = "\t",
            row.names = F, col.names = F, quote = F)
# append the gff itself
write.table(x = gff.4, 
            file = "annot_processing/Assembled_transcripts_with_no_annotation_overlap_clean_changed_IDs.gff", 
            sep = "\t",
            row.names = F, col.names = F, quote = F, append = T)
```


## Statistics of annotation and extraction of protein and coding sequences using AGAT
```{sh}
# interactive job
qsub -I -l select=1:ncpus=1:mem=8gb:scratch_local=10gb -l walltime=2:00:00

cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/stat_annotation

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# basic statistics
agat_sq_stat_basic.pl -i ../annot_processing/alyssum_annotation_01.gff -g ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa > stat_basic_alyssum_annotation_01.gff.txt

# detailed statistics
agat_sp_statistics.pl -i ../annot_processing/alyssum_annotation_01.gff -g ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa > stat_detailed_alyssum_annotation_01.gff.txt
```

Type (3rd column)	Number	Size total (kb)	Size mean (bp)	% of the genome
cds	              173921	42686.71	      245.44	        6.25
exon	            250209	63637.83	      254.34	        9.31
gene	            32073	  62652.25	      1953.43	        9.17
intron	          138011	29917.95	      216.78	        4.38
ncrna	            30166	  53606.29	      1777.04	        7.84
ncrna_gene	      23116	  37393.54	      1617.65	        5.47
start_codon	      35902	  107.68	        3.00	          0.02
stop_codon	      35902	  107.69	        3.00	          0.02
transcript	      35910	  72604.66	      2021.85	        10.62
Total	            755210	362714.59	      480.28	        53.08


The proteins and CDSs should be same as for alyssum_01_changed_IDs.gff, but I will extract it again.

```{sh}
cd /storage/brno12-cerit/home/duchmil/annotations/alyssum_2024_Mahnaz_assembly/annot_processing

# run the container
singularity run /storage/brno12-cerit/home/duchmil/SW/agat/agat_1.4.0--pl5321hdfd78af_0.sif

# Protein sequences
agat_sp_extract_sequences.pl -g alyssum_annotation_01.gff -f ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa -p -o alyssum_annotation_01_proteins.fasta
# CDS
agat_sp_extract_sequences.pl -g alyssum_annotation_01.gff -f ../genome_assembly/alyssum_v2_Mahnaz_2024_masked.fa -t cds -o alyssum_annotation_01_cds.fasta

# counting the number of sequences
grep -c ">" alyssum_annotation_01_proteins.fasta
grep -c ">" alyssum_annotation_01_cds.fasta


# converting from folded fasta to unfolded fasta for better counting and checking for internal stop codons
awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' < alyssum_annotation_01_proteins.fasta | grep \*[[:alpha:]] | wc -l
# 0
```



## Filter annotation file with AGAT
AGAT for filtration using list of genes
- sp filter feature from keep list
- produce high confidence gff (the original onewill be high+low confidence gff)
```{sh}
qsub -I -l select=1:ncpus=1:mem=64gb -l walltime=3:00:00
# loading and activating AGAT
module load conda-modules
conda activate agat
# convert to the right GFF? Try that...
agat_convert_sp_gxf2gxf.pl -v 3 --gff Alyssum_1_braker.gtf > Alyssum_1_braker_AGAT_fixed.gtf

# This got stuck:
agat_sp_filter_feature_from_keep_list.pl --gff Alyssum_1_braker.gtf --keep_list transcript_braker_and_protein_braker_meta_union_gene_ids.txt > Alyssum_1_braker_confident.gtf

```

## Statistics of annotation using AGAT
```{sh}
# loading and activating AGAT
module load conda-modules
conda activate agat
# basic statistics
agat_sq_stat_basic.pl -i Alyssum_1_braker.gtf -g ../input_data/reference_genome/Alyssum_ref_Sonia.fa.masked > stat_basic_Alyssum_1_braker.txt

```
Basic statistics
- CDS is not connected in one transcript (or the AGAT does not consider that to be connected)
- mRNA is annotated just in genes predicted by GeneMark, not in the genes predicted by Augustus




Additional checks
- gene length distribution
- run Busco on annotation (protein seqs)


GFF processing tools
- gffread
- AGAT

Functional annotation
- Interpro scan
  - some functional information (domains)
- Orthofinder, transfer info from A. thaliana
  
Chromosome naming
- A. lyrata to use as the reference
  - ideally the same chromosome numbers
  - same oriantation


### Problems with transcript filtering
```{sh}

agat_sp_filter_feature_from_keep_list.pl --gff ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean.gff

agat_sp_filter_feature_from_keep_list.pl --type transcript --gff ../rnaseq/4_assembled_transcripts/Assembled_transcripts.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_2.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff # 31088
grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_2.gff # 31088
# I don't know why is there more transcripts than in keep list.

grep -P "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff | sed -E 's/^.*;transcript_id=//g' | head
grep -P "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff | sed -E 's/^.*;transcript_id=//g' | sort | head -n 100

cat Assembled_transcripts_with_no_annotation_overlap.txt  | sort | head  -n 100

paste <(cat Assembled_transcripts_with_no_annotation_overlap.txt  | sort | head  -n 100) <(grep -P "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean.gff | sed -E 's/^.*;transcript_id=//g' | sort | head -n 100)


agat_convert_sp_gxf2gxf.pl -g Assembled_transcripts_with_no_annotation_overlap.gtf -o Assembled_transcripts_with_no_annotation_overlap.gff

agat_sp_filter_feature_from_keep_list.pl --type transcript --gff Assembled_transcripts_with_no_annotation_overlap.gff --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_3.gff
agat_sp_filter_feature_from_keep_list.pl --type transcript --gff Assembled_transcripts_with_no_annotation_overlap.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_4.gff
agat_sp_filter_feature_from_keep_list.pl --gff Assembled_transcripts_with_no_annotation_overlap.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_5.gff
agat_sp_filter_feature_from_keep_list.pl --type transcript,RNA --gff Assembled_transcripts_with_no_annotation_overlap.gtf --keep_list Assembled_transcripts_with_no_annotation_overlap.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_6.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_3.gff
grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_4.gff

grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_4.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_5.gff
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_5.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff
grep -P "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff | head -n 100
grep -P "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff | sed -E 's/^.*;transcript_id=//g' | head -n 100

agat_sp_filter_feature_from_kill_list.pl --gff Assembled_transcripts_with_no_annotation_overlap_clean_6.gff --kill_list <(grep -P "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff | sed -E 's/^.*;transcript_id=//g') -o Assembled_transcripts_with_no_annotation_overlap_clean_7.gff


grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_7.gff
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_7.gff

# Still not solved!!!

grep -P "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_6.gff | sed -E 's/^.*;transcript_id=//g' > transcript_kill_list.txt

agat_sp_filter_feature_from_kill_list.pl --gff Assembled_transcripts_with_no_annotation_overlap_clean_6.gff --kill_list transcript_kill_list.txt -o Assembled_transcripts_with_no_annotation_overlap_clean_8.gff

grep -P -c "\ttranscript\t" Assembled_transcripts_with_no_annotation_overlap_clean_8.gff
grep -P -c "\tRNA\t" Assembled_transcripts_with_no_annotation_overlap_clean_8.gff

mkdir trash

find . -maxdepth 1 -type f -mtime -3 -exec mv -t trash/ {} \;
```



```{sh}
# Check types of features in NCBI annotation
cd /storage/brno12-cerit/home/duchmil/lyrata_vcf/ncbi_lyrata_reference_101

grep -v '^#' GCF_000004255.2_v.1.0_genomic.gff | cut -f 3 | sort | uniq
grep '\tlnc_RNA\t' GCF_000004255.2_v.1.0_genomic.gff | head
```

ncRNA_gene
transcribed_region
